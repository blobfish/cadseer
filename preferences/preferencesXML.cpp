// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "preferencesXML.h"

namespace prf
{
  // DecPositive
  // 


  // Mesh
  // 

  const Mesh::LinearDeflectionType& Mesh::
  linearDeflection () const
  {
    return this->linearDeflection_.get ();
  }

  Mesh::LinearDeflectionType& Mesh::
  linearDeflection ()
  {
    return this->linearDeflection_.get ();
  }

  void Mesh::
  linearDeflection (const LinearDeflectionType& x)
  {
    this->linearDeflection_.set (x);
  }

  void Mesh::
  linearDeflection (::std::unique_ptr< LinearDeflectionType > x)
  {
    this->linearDeflection_.set (std::move (x));
  }

  Mesh::LinearDeflectionType Mesh::
  linearDeflection_default_value ()
  {
    return LinearDeflectionType (.25);
  }

  const Mesh::AngularDeflectionType& Mesh::
  angularDeflection () const
  {
    return this->angularDeflection_.get ();
  }

  Mesh::AngularDeflectionType& Mesh::
  angularDeflection ()
  {
    return this->angularDeflection_.get ();
  }

  void Mesh::
  angularDeflection (const AngularDeflectionType& x)
  {
    this->angularDeflection_.set (x);
  }

  void Mesh::
  angularDeflection (::std::unique_ptr< AngularDeflectionType > x)
  {
    this->angularDeflection_.set (std::move (x));
  }

  Mesh::AngularDeflectionType Mesh::
  angularDeflection_default_value ()
  {
    return AngularDeflectionType (.5);
  }


  // Display
  // 

  const Display::ShowHiddenLinesType& Display::
  showHiddenLines () const
  {
    return this->showHiddenLines_.get ();
  }

  Display::ShowHiddenLinesType& Display::
  showHiddenLines ()
  {
    return this->showHiddenLines_.get ();
  }

  void Display::
  showHiddenLines (const ShowHiddenLinesType& x)
  {
    this->showHiddenLines_.set (x);
  }

  Display::ShowHiddenLinesType Display::
  showHiddenLines_default_value ()
  {
    return ShowHiddenLinesType (false);
  }

  const Display::ShowCurrentSystemType& Display::
  showCurrentSystem () const
  {
    return this->showCurrentSystem_.get ();
  }

  Display::ShowCurrentSystemType& Display::
  showCurrentSystem ()
  {
    return this->showCurrentSystem_.get ();
  }

  void Display::
  showCurrentSystem (const ShowCurrentSystemType& x)
  {
    this->showCurrentSystem_.set (x);
  }

  Display::ShowCurrentSystemType Display::
  showCurrentSystem_default_value ()
  {
    return ShowCurrentSystemType (true);
  }


  // Visual
  // 

  const Visual::MeshType& Visual::
  mesh () const
  {
    return this->mesh_.get ();
  }

  Visual::MeshType& Visual::
  mesh ()
  {
    return this->mesh_.get ();
  }

  void Visual::
  mesh (const MeshType& x)
  {
    this->mesh_.set (x);
  }

  void Visual::
  mesh (::std::unique_ptr< MeshType > x)
  {
    this->mesh_.set (std::move (x));
  }

  const Visual::DisplayType& Visual::
  display () const
  {
    return this->display_.get ();
  }

  Visual::DisplayType& Visual::
  display ()
  {
    return this->display_.get ();
  }

  void Visual::
  display (const DisplayType& x)
  {
    this->display_.set (x);
  }

  void Visual::
  display (::std::unique_ptr< DisplayType > x)
  {
    this->display_.set (std::move (x));
  }


  // Dragger
  // 

  const Dragger::TriggerUpdateOnFinishType& Dragger::
  triggerUpdateOnFinish () const
  {
    return this->triggerUpdateOnFinish_.get ();
  }

  Dragger::TriggerUpdateOnFinishType& Dragger::
  triggerUpdateOnFinish ()
  {
    return this->triggerUpdateOnFinish_.get ();
  }

  void Dragger::
  triggerUpdateOnFinish (const TriggerUpdateOnFinishType& x)
  {
    this->triggerUpdateOnFinish_.set (x);
  }

  Dragger::TriggerUpdateOnFinishType Dragger::
  triggerUpdateOnFinish_default_value ()
  {
    return TriggerUpdateOnFinishType (false);
  }

  const Dragger::LinearIncrementType& Dragger::
  linearIncrement () const
  {
    return this->linearIncrement_.get ();
  }

  Dragger::LinearIncrementType& Dragger::
  linearIncrement ()
  {
    return this->linearIncrement_.get ();
  }

  void Dragger::
  linearIncrement (const LinearIncrementType& x)
  {
    this->linearIncrement_.set (x);
  }

  void Dragger::
  linearIncrement (::std::unique_ptr< LinearIncrementType > x)
  {
    this->linearIncrement_.set (std::move (x));
  }

  Dragger::LinearIncrementType Dragger::
  linearIncrement_default_value ()
  {
    return LinearIncrementType (1.0);
  }

  const Dragger::AngularIncrementType& Dragger::
  angularIncrement () const
  {
    return this->angularIncrement_.get ();
  }

  Dragger::AngularIncrementType& Dragger::
  angularIncrement ()
  {
    return this->angularIncrement_.get ();
  }

  void Dragger::
  angularIncrement (const AngularIncrementType& x)
  {
    this->angularIncrement_.set (x);
  }

  void Dragger::
  angularIncrement (::std::unique_ptr< AngularIncrementType > x)
  {
    this->angularIncrement_.set (std::move (x));
  }

  Dragger::AngularIncrementType Dragger::
  angularIncrement_default_value ()
  {
    return AngularIncrementType (15.0);
  }


  // InteractiveParameter
  // 

  const InteractiveParameter::CharacterSizeType& InteractiveParameter::
  characterSize () const
  {
    return this->characterSize_.get ();
  }

  InteractiveParameter::CharacterSizeType& InteractiveParameter::
  characterSize ()
  {
    return this->characterSize_.get ();
  }

  void InteractiveParameter::
  characterSize (const CharacterSizeType& x)
  {
    this->characterSize_.set (x);
  }

  void InteractiveParameter::
  characterSize (::std::unique_ptr< CharacterSizeType > x)
  {
    this->characterSize_.set (std::move (x));
  }

  InteractiveParameter::CharacterSizeType InteractiveParameter::
  characterSize_default_value ()
  {
    return CharacterSizeType (1.0);
  }

  const InteractiveParameter::ArrowWidthType& InteractiveParameter::
  arrowWidth () const
  {
    return this->arrowWidth_.get ();
  }

  InteractiveParameter::ArrowWidthType& InteractiveParameter::
  arrowWidth ()
  {
    return this->arrowWidth_.get ();
  }

  void InteractiveParameter::
  arrowWidth (const ArrowWidthType& x)
  {
    this->arrowWidth_.set (x);
  }

  void InteractiveParameter::
  arrowWidth (::std::unique_ptr< ArrowWidthType > x)
  {
    this->arrowWidth_.set (std::move (x));
  }

  InteractiveParameter::ArrowWidthType InteractiveParameter::
  arrowWidth_default_value ()
  {
    return ArrowWidthType (.5);
  }

  const InteractiveParameter::ArrowHeightType& InteractiveParameter::
  arrowHeight () const
  {
    return this->arrowHeight_.get ();
  }

  InteractiveParameter::ArrowHeightType& InteractiveParameter::
  arrowHeight ()
  {
    return this->arrowHeight_.get ();
  }

  void InteractiveParameter::
  arrowHeight (const ArrowHeightType& x)
  {
    this->arrowHeight_.set (x);
  }

  void InteractiveParameter::
  arrowHeight (::std::unique_ptr< ArrowHeightType > x)
  {
    this->arrowHeight_.set (std::move (x));
  }

  InteractiveParameter::ArrowHeightType InteractiveParameter::
  arrowHeight_default_value ()
  {
    return ArrowHeightType (1.0);
  }


  // Gesture
  // 

  const Gesture::AnimationSecondsType& Gesture::
  animationSeconds () const
  {
    return this->animationSeconds_.get ();
  }

  Gesture::AnimationSecondsType& Gesture::
  animationSeconds ()
  {
    return this->animationSeconds_.get ();
  }

  void Gesture::
  animationSeconds (const AnimationSecondsType& x)
  {
    this->animationSeconds_.set (x);
  }

  void Gesture::
  animationSeconds (::std::unique_ptr< AnimationSecondsType > x)
  {
    this->animationSeconds_.set (std::move (x));
  }

  Gesture::AnimationSecondsType Gesture::
  animationSeconds_default_value ()
  {
    return AnimationSecondsType (1.0);
  }

  const Gesture::IconRadiusType& Gesture::
  iconRadius () const
  {
    return this->iconRadius_.get ();
  }

  Gesture::IconRadiusType& Gesture::
  iconRadius ()
  {
    return this->iconRadius_.get ();
  }

  void Gesture::
  iconRadius (const IconRadiusType& x)
  {
    this->iconRadius_.set (x);
  }

  Gesture::IconRadiusType Gesture::
  iconRadius_default_value ()
  {
    return IconRadiusType (32);
  }

  const Gesture::IncludeAngleType& Gesture::
  includeAngle () const
  {
    return this->includeAngle_.get ();
  }

  Gesture::IncludeAngleType& Gesture::
  includeAngle ()
  {
    return this->includeAngle_.get ();
  }

  void Gesture::
  includeAngle (const IncludeAngleType& x)
  {
    this->includeAngle_.set (x);
  }

  Gesture::IncludeAngleType Gesture::
  includeAngle_default_value ()
  {
    return IncludeAngleType (90);
  }

  const Gesture::SpreadFactorType& Gesture::
  spreadFactor () const
  {
    return this->spreadFactor_.get ();
  }

  Gesture::SpreadFactorType& Gesture::
  spreadFactor ()
  {
    return this->spreadFactor_.get ();
  }

  void Gesture::
  spreadFactor (const SpreadFactorType& x)
  {
    this->spreadFactor_.set (x);
  }

  void Gesture::
  spreadFactor (::std::unique_ptr< SpreadFactorType > x)
  {
    this->spreadFactor_.set (std::move (x));
  }

  Gesture::SpreadFactorType Gesture::
  spreadFactor_default_value ()
  {
    return SpreadFactorType (.10);
  }

  const Gesture::SprayFactorType& Gesture::
  sprayFactor () const
  {
    return this->sprayFactor_.get ();
  }

  Gesture::SprayFactorType& Gesture::
  sprayFactor ()
  {
    return this->sprayFactor_.get ();
  }

  void Gesture::
  sprayFactor (const SprayFactorType& x)
  {
    this->sprayFactor_.set (x);
  }

  void Gesture::
  sprayFactor (::std::unique_ptr< SprayFactorType > x)
  {
    this->sprayFactor_.set (std::move (x));
  }

  Gesture::SprayFactorType Gesture::
  sprayFactor_default_value ()
  {
    return SprayFactorType (1.0);
  }


  // RecentProjects
  // 

  const RecentProjects::EntrySequence& RecentProjects::
  Entry () const
  {
    return this->Entry_;
  }

  RecentProjects::EntrySequence& RecentProjects::
  Entry ()
  {
    return this->Entry_;
  }

  void RecentProjects::
  Entry (const EntrySequence& s)
  {
    this->Entry_ = s;
  }


  // Project
  // 

  const Project::BasePathType& Project::
  basePath () const
  {
    return this->basePath_.get ();
  }

  Project::BasePathType& Project::
  basePath ()
  {
    return this->basePath_.get ();
  }

  void Project::
  basePath (const BasePathType& x)
  {
    this->basePath_.set (x);
  }

  void Project::
  basePath (::std::unique_ptr< BasePathType > x)
  {
    this->basePath_.set (std::move (x));
  }

  const Project::GitNameType& Project::
  gitName () const
  {
    return this->gitName_.get ();
  }

  Project::GitNameType& Project::
  gitName ()
  {
    return this->gitName_.get ();
  }

  void Project::
  gitName (const GitNameType& x)
  {
    this->gitName_.set (x);
  }

  void Project::
  gitName (::std::unique_ptr< GitNameType > x)
  {
    this->gitName_.set (std::move (x));
  }

  const Project::GitEmailType& Project::
  gitEmail () const
  {
    return this->gitEmail_.get ();
  }

  Project::GitEmailType& Project::
  gitEmail ()
  {
    return this->gitEmail_.get ();
  }

  void Project::
  gitEmail (const GitEmailType& x)
  {
    this->gitEmail_.set (x);
  }

  void Project::
  gitEmail (::std::unique_ptr< GitEmailType > x)
  {
    this->gitEmail_.set (std::move (x));
  }

  const Project::RecentProjectsType& Project::
  recentProjects () const
  {
    return this->recentProjects_.get ();
  }

  Project::RecentProjectsType& Project::
  recentProjects ()
  {
    return this->recentProjects_.get ();
  }

  void Project::
  recentProjects (const RecentProjectsType& x)
  {
    this->recentProjects_.set (x);
  }

  void Project::
  recentProjects (::std::unique_ptr< RecentProjectsType > x)
  {
    this->recentProjects_.set (std::move (x));
  }


  // SpaceballButton
  // 

  const SpaceballButton::NumberType& SpaceballButton::
  number () const
  {
    return this->number_.get ();
  }

  SpaceballButton::NumberType& SpaceballButton::
  number ()
  {
    return this->number_.get ();
  }

  void SpaceballButton::
  number (const NumberType& x)
  {
    this->number_.set (x);
  }

  const SpaceballButton::MaskType& SpaceballButton::
  mask () const
  {
    return this->mask_.get ();
  }

  SpaceballButton::MaskType& SpaceballButton::
  mask ()
  {
    return this->mask_.get ();
  }

  void SpaceballButton::
  mask (const MaskType& x)
  {
    this->mask_.set (x);
  }

  void SpaceballButton::
  mask (::std::unique_ptr< MaskType > x)
  {
    this->mask_.set (std::move (x));
  }


  // SpaceballButtons
  // 

  const SpaceballButtons::ArraySequence& SpaceballButtons::
  array () const
  {
    return this->array_;
  }

  SpaceballButtons::ArraySequence& SpaceballButtons::
  array ()
  {
    return this->array_;
  }

  void SpaceballButtons::
  array (const ArraySequence& s)
  {
    this->array_ = s;
  }


  // HotKeys
  // 

  const HotKeys::SpaceballButtonsType& HotKeys::
  spaceballButtons () const
  {
    return this->spaceballButtons_.get ();
  }

  HotKeys::SpaceballButtonsType& HotKeys::
  spaceballButtons ()
  {
    return this->spaceballButtons_.get ();
  }

  void HotKeys::
  spaceballButtons (const SpaceballButtonsType& x)
  {
    this->spaceballButtons_.set (x);
  }

  void HotKeys::
  spaceballButtons (::std::unique_ptr< SpaceballButtonsType > x)
  {
    this->spaceballButtons_.set (std::move (x));
  }


  // Root
  // 

  const Root::VisualType& Root::
  visual () const
  {
    return this->visual_.get ();
  }

  Root::VisualType& Root::
  visual ()
  {
    return this->visual_.get ();
  }

  void Root::
  visual (const VisualType& x)
  {
    this->visual_.set (x);
  }

  void Root::
  visual (::std::unique_ptr< VisualType > x)
  {
    this->visual_.set (std::move (x));
  }

  const Root::DraggerType& Root::
  dragger () const
  {
    return this->dragger_.get ();
  }

  Root::DraggerType& Root::
  dragger ()
  {
    return this->dragger_.get ();
  }

  void Root::
  dragger (const DraggerType& x)
  {
    this->dragger_.set (x);
  }

  void Root::
  dragger (::std::unique_ptr< DraggerType > x)
  {
    this->dragger_.set (std::move (x));
  }

  const Root::InteractiveParameterType& Root::
  interactiveParameter () const
  {
    return this->interactiveParameter_.get ();
  }

  Root::InteractiveParameterType& Root::
  interactiveParameter ()
  {
    return this->interactiveParameter_.get ();
  }

  void Root::
  interactiveParameter (const InteractiveParameterType& x)
  {
    this->interactiveParameter_.set (x);
  }

  void Root::
  interactiveParameter (::std::unique_ptr< InteractiveParameterType > x)
  {
    this->interactiveParameter_.set (std::move (x));
  }

  const Root::GestureType& Root::
  gesture () const
  {
    return this->gesture_.get ();
  }

  Root::GestureType& Root::
  gesture ()
  {
    return this->gesture_.get ();
  }

  void Root::
  gesture (const GestureType& x)
  {
    this->gesture_.set (x);
  }

  void Root::
  gesture (::std::unique_ptr< GestureType > x)
  {
    this->gesture_.set (std::move (x));
  }

  const Root::ProjectType& Root::
  project () const
  {
    return this->project_.get ();
  }

  Root::ProjectType& Root::
  project ()
  {
    return this->project_.get ();
  }

  void Root::
  project (const ProjectType& x)
  {
    this->project_.set (x);
  }

  void Root::
  project (::std::unique_ptr< ProjectType > x)
  {
    this->project_.set (std::move (x));
  }

  const Root::HotKeysType& Root::
  hotKeys () const
  {
    return this->hotKeys_.get ();
  }

  Root::HotKeysType& Root::
  hotKeys ()
  {
    return this->hotKeys_.get ();
  }

  void Root::
  hotKeys (const HotKeysType& x)
  {
    this->hotKeys_.set (x);
  }

  void Root::
  hotKeys (::std::unique_ptr< HotKeysType > x)
  {
    this->hotKeys_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace prf
{
  // DecPositive
  //

  DecPositive::
  DecPositive (const ::xml_schema::Decimal& _xsd_Decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (_xsd_Decimal_base)
  {
  }

  DecPositive::
  DecPositive (const DecPositive& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
  }

  DecPositive::
  DecPositive (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
  }

  DecPositive::
  DecPositive (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
  }

  DecPositive::
  DecPositive (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
  }

  DecPositive* DecPositive::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DecPositive (*this, f, c);
  }

  DecPositive::
  ~DecPositive ()
  {
  }

  // Mesh
  //

  Mesh::
  Mesh (const LinearDeflectionType& linearDeflection,
        const AngularDeflectionType& angularDeflection)
  : ::xml_schema::Type (),
    linearDeflection_ (linearDeflection, this),
    angularDeflection_ (angularDeflection, this)
  {
  }

  Mesh::
  Mesh (const Mesh& x,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    linearDeflection_ (x.linearDeflection_, f, this),
    angularDeflection_ (x.angularDeflection_, f, this)
  {
  }

  Mesh::
  Mesh (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    linearDeflection_ (this),
    angularDeflection_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Mesh::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // linearDeflection
      //
      if (n.name () == "linearDeflection" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< LinearDeflectionType > r (
          LinearDeflectionTraits::create (i, f, this));

        if (!linearDeflection_.present ())
        {
          this->linearDeflection_.set (::std::move (r));
          continue;
        }
      }

      // angularDeflection
      //
      if (n.name () == "angularDeflection" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AngularDeflectionType > r (
          AngularDeflectionTraits::create (i, f, this));

        if (!angularDeflection_.present ())
        {
          this->angularDeflection_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!linearDeflection_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "linearDeflection",
        "");
    }

    if (!angularDeflection_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "angularDeflection",
        "");
    }
  }

  Mesh* Mesh::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Mesh (*this, f, c);
  }

  Mesh& Mesh::
  operator= (const Mesh& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->linearDeflection_ = x.linearDeflection_;
      this->angularDeflection_ = x.angularDeflection_;
    }

    return *this;
  }

  Mesh::
  ~Mesh ()
  {
  }

  // Display
  //

  Display::
  Display (const ShowHiddenLinesType& showHiddenLines,
           const ShowCurrentSystemType& showCurrentSystem)
  : ::xml_schema::Type (),
    showHiddenLines_ (showHiddenLines, this),
    showCurrentSystem_ (showCurrentSystem, this)
  {
  }

  Display::
  Display (const Display& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    showHiddenLines_ (x.showHiddenLines_, f, this),
    showCurrentSystem_ (x.showCurrentSystem_, f, this)
  {
  }

  Display::
  Display (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    showHiddenLines_ (this),
    showCurrentSystem_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Display::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // showHiddenLines
      //
      if (n.name () == "showHiddenLines" && n.namespace_ ().empty ())
      {
        if (!showHiddenLines_.present ())
        {
          this->showHiddenLines_.set (ShowHiddenLinesTraits::create (i, f, this));
          continue;
        }
      }

      // showCurrentSystem
      //
      if (n.name () == "showCurrentSystem" && n.namespace_ ().empty ())
      {
        if (!showCurrentSystem_.present ())
        {
          this->showCurrentSystem_.set (ShowCurrentSystemTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!showHiddenLines_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "showHiddenLines",
        "");
    }

    if (!showCurrentSystem_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "showCurrentSystem",
        "");
    }
  }

  Display* Display::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Display (*this, f, c);
  }

  Display& Display::
  operator= (const Display& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->showHiddenLines_ = x.showHiddenLines_;
      this->showCurrentSystem_ = x.showCurrentSystem_;
    }

    return *this;
  }

  Display::
  ~Display ()
  {
  }

  // Visual
  //

  Visual::
  Visual (const MeshType& mesh,
          const DisplayType& display)
  : ::xml_schema::Type (),
    mesh_ (mesh, this),
    display_ (display, this)
  {
  }

  Visual::
  Visual (::std::unique_ptr< MeshType > mesh,
          ::std::unique_ptr< DisplayType > display)
  : ::xml_schema::Type (),
    mesh_ (std::move (mesh), this),
    display_ (std::move (display), this)
  {
  }

  Visual::
  Visual (const Visual& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    mesh_ (x.mesh_, f, this),
    display_ (x.display_, f, this)
  {
  }

  Visual::
  Visual (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    mesh_ (this),
    display_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Visual::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // mesh
      //
      if (n.name () == "mesh" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MeshType > r (
          MeshTraits::create (i, f, this));

        if (!mesh_.present ())
        {
          this->mesh_.set (::std::move (r));
          continue;
        }
      }

      // display
      //
      if (n.name () == "display" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DisplayType > r (
          DisplayTraits::create (i, f, this));

        if (!display_.present ())
        {
          this->display_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!mesh_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mesh",
        "");
    }

    if (!display_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "display",
        "");
    }
  }

  Visual* Visual::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Visual (*this, f, c);
  }

  Visual& Visual::
  operator= (const Visual& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->mesh_ = x.mesh_;
      this->display_ = x.display_;
    }

    return *this;
  }

  Visual::
  ~Visual ()
  {
  }

  // Dragger
  //

  Dragger::
  Dragger (const TriggerUpdateOnFinishType& triggerUpdateOnFinish,
           const LinearIncrementType& linearIncrement,
           const AngularIncrementType& angularIncrement)
  : ::xml_schema::Type (),
    triggerUpdateOnFinish_ (triggerUpdateOnFinish, this),
    linearIncrement_ (linearIncrement, this),
    angularIncrement_ (angularIncrement, this)
  {
  }

  Dragger::
  Dragger (const Dragger& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    triggerUpdateOnFinish_ (x.triggerUpdateOnFinish_, f, this),
    linearIncrement_ (x.linearIncrement_, f, this),
    angularIncrement_ (x.angularIncrement_, f, this)
  {
  }

  Dragger::
  Dragger (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    triggerUpdateOnFinish_ (this),
    linearIncrement_ (this),
    angularIncrement_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Dragger::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // triggerUpdateOnFinish
      //
      if (n.name () == "triggerUpdateOnFinish" && n.namespace_ ().empty ())
      {
        if (!triggerUpdateOnFinish_.present ())
        {
          this->triggerUpdateOnFinish_.set (TriggerUpdateOnFinishTraits::create (i, f, this));
          continue;
        }
      }

      // linearIncrement
      //
      if (n.name () == "linearIncrement" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< LinearIncrementType > r (
          LinearIncrementTraits::create (i, f, this));

        if (!linearIncrement_.present ())
        {
          this->linearIncrement_.set (::std::move (r));
          continue;
        }
      }

      // angularIncrement
      //
      if (n.name () == "angularIncrement" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AngularIncrementType > r (
          AngularIncrementTraits::create (i, f, this));

        if (!angularIncrement_.present ())
        {
          this->angularIncrement_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!triggerUpdateOnFinish_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "triggerUpdateOnFinish",
        "");
    }

    if (!linearIncrement_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "linearIncrement",
        "");
    }

    if (!angularIncrement_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "angularIncrement",
        "");
    }
  }

  Dragger* Dragger::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Dragger (*this, f, c);
  }

  Dragger& Dragger::
  operator= (const Dragger& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->triggerUpdateOnFinish_ = x.triggerUpdateOnFinish_;
      this->linearIncrement_ = x.linearIncrement_;
      this->angularIncrement_ = x.angularIncrement_;
    }

    return *this;
  }

  Dragger::
  ~Dragger ()
  {
  }

  // InteractiveParameter
  //

  InteractiveParameter::
  InteractiveParameter (const CharacterSizeType& characterSize,
                        const ArrowWidthType& arrowWidth,
                        const ArrowHeightType& arrowHeight)
  : ::xml_schema::Type (),
    characterSize_ (characterSize, this),
    arrowWidth_ (arrowWidth, this),
    arrowHeight_ (arrowHeight, this)
  {
  }

  InteractiveParameter::
  InteractiveParameter (const InteractiveParameter& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    characterSize_ (x.characterSize_, f, this),
    arrowWidth_ (x.arrowWidth_, f, this),
    arrowHeight_ (x.arrowHeight_, f, this)
  {
  }

  InteractiveParameter::
  InteractiveParameter (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    characterSize_ (this),
    arrowWidth_ (this),
    arrowHeight_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void InteractiveParameter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // characterSize
      //
      if (n.name () == "characterSize" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< CharacterSizeType > r (
          CharacterSizeTraits::create (i, f, this));

        if (!characterSize_.present ())
        {
          this->characterSize_.set (::std::move (r));
          continue;
        }
      }

      // arrowWidth
      //
      if (n.name () == "arrowWidth" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ArrowWidthType > r (
          ArrowWidthTraits::create (i, f, this));

        if (!arrowWidth_.present ())
        {
          this->arrowWidth_.set (::std::move (r));
          continue;
        }
      }

      // arrowHeight
      //
      if (n.name () == "arrowHeight" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ArrowHeightType > r (
          ArrowHeightTraits::create (i, f, this));

        if (!arrowHeight_.present ())
        {
          this->arrowHeight_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!characterSize_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "characterSize",
        "");
    }

    if (!arrowWidth_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "arrowWidth",
        "");
    }

    if (!arrowHeight_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "arrowHeight",
        "");
    }
  }

  InteractiveParameter* InteractiveParameter::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InteractiveParameter (*this, f, c);
  }

  InteractiveParameter& InteractiveParameter::
  operator= (const InteractiveParameter& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->characterSize_ = x.characterSize_;
      this->arrowWidth_ = x.arrowWidth_;
      this->arrowHeight_ = x.arrowHeight_;
    }

    return *this;
  }

  InteractiveParameter::
  ~InteractiveParameter ()
  {
  }

  // Gesture
  //

  Gesture::
  Gesture (const AnimationSecondsType& animationSeconds,
           const IconRadiusType& iconRadius,
           const IncludeAngleType& includeAngle,
           const SpreadFactorType& spreadFactor,
           const SprayFactorType& sprayFactor)
  : ::xml_schema::Type (),
    animationSeconds_ (animationSeconds, this),
    iconRadius_ (iconRadius, this),
    includeAngle_ (includeAngle, this),
    spreadFactor_ (spreadFactor, this),
    sprayFactor_ (sprayFactor, this)
  {
  }

  Gesture::
  Gesture (const Gesture& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    animationSeconds_ (x.animationSeconds_, f, this),
    iconRadius_ (x.iconRadius_, f, this),
    includeAngle_ (x.includeAngle_, f, this),
    spreadFactor_ (x.spreadFactor_, f, this),
    sprayFactor_ (x.sprayFactor_, f, this)
  {
  }

  Gesture::
  Gesture (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    animationSeconds_ (this),
    iconRadius_ (this),
    includeAngle_ (this),
    spreadFactor_ (this),
    sprayFactor_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Gesture::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // animationSeconds
      //
      if (n.name () == "animationSeconds" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AnimationSecondsType > r (
          AnimationSecondsTraits::create (i, f, this));

        if (!animationSeconds_.present ())
        {
          this->animationSeconds_.set (::std::move (r));
          continue;
        }
      }

      // iconRadius
      //
      if (n.name () == "iconRadius" && n.namespace_ ().empty ())
      {
        if (!iconRadius_.present ())
        {
          this->iconRadius_.set (IconRadiusTraits::create (i, f, this));
          continue;
        }
      }

      // includeAngle
      //
      if (n.name () == "includeAngle" && n.namespace_ ().empty ())
      {
        if (!includeAngle_.present ())
        {
          this->includeAngle_.set (IncludeAngleTraits::create (i, f, this));
          continue;
        }
      }

      // spreadFactor
      //
      if (n.name () == "spreadFactor" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SpreadFactorType > r (
          SpreadFactorTraits::create (i, f, this));

        if (!spreadFactor_.present ())
        {
          this->spreadFactor_.set (::std::move (r));
          continue;
        }
      }

      // sprayFactor
      //
      if (n.name () == "sprayFactor" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SprayFactorType > r (
          SprayFactorTraits::create (i, f, this));

        if (!sprayFactor_.present ())
        {
          this->sprayFactor_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!animationSeconds_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "animationSeconds",
        "");
    }

    if (!iconRadius_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "iconRadius",
        "");
    }

    if (!includeAngle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "includeAngle",
        "");
    }

    if (!spreadFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "spreadFactor",
        "");
    }

    if (!sprayFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "sprayFactor",
        "");
    }
  }

  Gesture* Gesture::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Gesture (*this, f, c);
  }

  Gesture& Gesture::
  operator= (const Gesture& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->animationSeconds_ = x.animationSeconds_;
      this->iconRadius_ = x.iconRadius_;
      this->includeAngle_ = x.includeAngle_;
      this->spreadFactor_ = x.spreadFactor_;
      this->sprayFactor_ = x.sprayFactor_;
    }

    return *this;
  }

  Gesture::
  ~Gesture ()
  {
  }

  // RecentProjects
  //

  RecentProjects::
  RecentProjects ()
  : ::xml_schema::Type (),
    Entry_ (this)
  {
  }

  RecentProjects::
  RecentProjects (const RecentProjects& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Entry_ (x.Entry_, f, this)
  {
  }

  RecentProjects::
  RecentProjects (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Entry_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void RecentProjects::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Entry
      //
      if (n.name () == "Entry" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< EntryType > r (
          EntryTraits::create (i, f, this));

        this->Entry_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  RecentProjects* RecentProjects::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RecentProjects (*this, f, c);
  }

  RecentProjects& RecentProjects::
  operator= (const RecentProjects& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Entry_ = x.Entry_;
    }

    return *this;
  }

  RecentProjects::
  ~RecentProjects ()
  {
  }

  // Project
  //

  Project::
  Project (const BasePathType& basePath,
           const GitNameType& gitName,
           const GitEmailType& gitEmail,
           const RecentProjectsType& recentProjects)
  : ::xml_schema::Type (),
    basePath_ (basePath, this),
    gitName_ (gitName, this),
    gitEmail_ (gitEmail, this),
    recentProjects_ (recentProjects, this)
  {
  }

  Project::
  Project (const BasePathType& basePath,
           const GitNameType& gitName,
           const GitEmailType& gitEmail,
           ::std::unique_ptr< RecentProjectsType > recentProjects)
  : ::xml_schema::Type (),
    basePath_ (basePath, this),
    gitName_ (gitName, this),
    gitEmail_ (gitEmail, this),
    recentProjects_ (std::move (recentProjects), this)
  {
  }

  Project::
  Project (const Project& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    basePath_ (x.basePath_, f, this),
    gitName_ (x.gitName_, f, this),
    gitEmail_ (x.gitEmail_, f, this),
    recentProjects_ (x.recentProjects_, f, this)
  {
  }

  Project::
  Project (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    basePath_ (this),
    gitName_ (this),
    gitEmail_ (this),
    recentProjects_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Project::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // basePath
      //
      if (n.name () == "basePath" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< BasePathType > r (
          BasePathTraits::create (i, f, this));

        if (!basePath_.present ())
        {
          this->basePath_.set (::std::move (r));
          continue;
        }
      }

      // gitName
      //
      if (n.name () == "gitName" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< GitNameType > r (
          GitNameTraits::create (i, f, this));

        if (!gitName_.present ())
        {
          this->gitName_.set (::std::move (r));
          continue;
        }
      }

      // gitEmail
      //
      if (n.name () == "gitEmail" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< GitEmailType > r (
          GitEmailTraits::create (i, f, this));

        if (!gitEmail_.present ())
        {
          this->gitEmail_.set (::std::move (r));
          continue;
        }
      }

      // recentProjects
      //
      if (n.name () == "recentProjects" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< RecentProjectsType > r (
          RecentProjectsTraits::create (i, f, this));

        if (!recentProjects_.present ())
        {
          this->recentProjects_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!basePath_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "basePath",
        "");
    }

    if (!gitName_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "gitName",
        "");
    }

    if (!gitEmail_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "gitEmail",
        "");
    }

    if (!recentProjects_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "recentProjects",
        "");
    }
  }

  Project* Project::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Project (*this, f, c);
  }

  Project& Project::
  operator= (const Project& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->basePath_ = x.basePath_;
      this->gitName_ = x.gitName_;
      this->gitEmail_ = x.gitEmail_;
      this->recentProjects_ = x.recentProjects_;
    }

    return *this;
  }

  Project::
  ~Project ()
  {
  }

  // SpaceballButton
  //

  SpaceballButton::
  SpaceballButton (const NumberType& number,
                   const MaskType& mask)
  : ::xml_schema::Type (),
    number_ (number, this),
    mask_ (mask, this)
  {
  }

  SpaceballButton::
  SpaceballButton (const SpaceballButton& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    number_ (x.number_, f, this),
    mask_ (x.mask_, f, this)
  {
  }

  SpaceballButton::
  SpaceballButton (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    number_ (this),
    mask_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SpaceballButton::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // number
      //
      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        if (!number_.present ())
        {
          this->number_.set (NumberTraits::create (i, f, this));
          continue;
        }
      }

      // mask
      //
      if (n.name () == "mask" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MaskType > r (
          MaskTraits::create (i, f, this));

        if (!mask_.present ())
        {
          this->mask_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!number_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "number",
        "");
    }

    if (!mask_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mask",
        "");
    }
  }

  SpaceballButton* SpaceballButton::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SpaceballButton (*this, f, c);
  }

  SpaceballButton& SpaceballButton::
  operator= (const SpaceballButton& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->number_ = x.number_;
      this->mask_ = x.mask_;
    }

    return *this;
  }

  SpaceballButton::
  ~SpaceballButton ()
  {
  }

  // SpaceballButtons
  //

  SpaceballButtons::
  SpaceballButtons ()
  : ::xml_schema::Type (),
    array_ (this)
  {
  }

  SpaceballButtons::
  SpaceballButtons (const SpaceballButtons& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    array_ (x.array_, f, this)
  {
  }

  SpaceballButtons::
  SpaceballButtons (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    array_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SpaceballButtons::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // array
      //
      if (n.name () == "array" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ArrayType > r (
          ArrayTraits::create (i, f, this));

        this->array_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  SpaceballButtons* SpaceballButtons::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SpaceballButtons (*this, f, c);
  }

  SpaceballButtons& SpaceballButtons::
  operator= (const SpaceballButtons& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->array_ = x.array_;
    }

    return *this;
  }

  SpaceballButtons::
  ~SpaceballButtons ()
  {
  }

  // HotKeys
  //

  HotKeys::
  HotKeys (const SpaceballButtonsType& spaceballButtons)
  : ::xml_schema::Type (),
    spaceballButtons_ (spaceballButtons, this)
  {
  }

  HotKeys::
  HotKeys (::std::unique_ptr< SpaceballButtonsType > spaceballButtons)
  : ::xml_schema::Type (),
    spaceballButtons_ (std::move (spaceballButtons), this)
  {
  }

  HotKeys::
  HotKeys (const HotKeys& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    spaceballButtons_ (x.spaceballButtons_, f, this)
  {
  }

  HotKeys::
  HotKeys (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    spaceballButtons_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void HotKeys::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // spaceballButtons
      //
      if (n.name () == "spaceballButtons" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SpaceballButtonsType > r (
          SpaceballButtonsTraits::create (i, f, this));

        if (!spaceballButtons_.present ())
        {
          this->spaceballButtons_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!spaceballButtons_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "spaceballButtons",
        "");
    }
  }

  HotKeys* HotKeys::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HotKeys (*this, f, c);
  }

  HotKeys& HotKeys::
  operator= (const HotKeys& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->spaceballButtons_ = x.spaceballButtons_;
    }

    return *this;
  }

  HotKeys::
  ~HotKeys ()
  {
  }

  // Root
  //

  Root::
  Root (const VisualType& visual,
        const DraggerType& dragger,
        const InteractiveParameterType& interactiveParameter,
        const GestureType& gesture,
        const ProjectType& project,
        const HotKeysType& hotKeys)
  : ::xml_schema::Type (),
    visual_ (visual, this),
    dragger_ (dragger, this),
    interactiveParameter_ (interactiveParameter, this),
    gesture_ (gesture, this),
    project_ (project, this),
    hotKeys_ (hotKeys, this)
  {
  }

  Root::
  Root (::std::unique_ptr< VisualType > visual,
        ::std::unique_ptr< DraggerType > dragger,
        ::std::unique_ptr< InteractiveParameterType > interactiveParameter,
        ::std::unique_ptr< GestureType > gesture,
        ::std::unique_ptr< ProjectType > project,
        ::std::unique_ptr< HotKeysType > hotKeys)
  : ::xml_schema::Type (),
    visual_ (std::move (visual), this),
    dragger_ (std::move (dragger), this),
    interactiveParameter_ (std::move (interactiveParameter), this),
    gesture_ (std::move (gesture), this),
    project_ (std::move (project), this),
    hotKeys_ (std::move (hotKeys), this)
  {
  }

  Root::
  Root (const Root& x,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    visual_ (x.visual_, f, this),
    dragger_ (x.dragger_, f, this),
    interactiveParameter_ (x.interactiveParameter_, f, this),
    gesture_ (x.gesture_, f, this),
    project_ (x.project_, f, this),
    hotKeys_ (x.hotKeys_, f, this)
  {
  }

  Root::
  Root (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    visual_ (this),
    dragger_ (this),
    interactiveParameter_ (this),
    gesture_ (this),
    project_ (this),
    hotKeys_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Root::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // visual
      //
      if (n.name () == "visual" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< VisualType > r (
          VisualTraits::create (i, f, this));

        if (!visual_.present ())
        {
          this->visual_.set (::std::move (r));
          continue;
        }
      }

      // dragger
      //
      if (n.name () == "dragger" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DraggerType > r (
          DraggerTraits::create (i, f, this));

        if (!dragger_.present ())
        {
          this->dragger_.set (::std::move (r));
          continue;
        }
      }

      // interactiveParameter
      //
      if (n.name () == "interactiveParameter" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< InteractiveParameterType > r (
          InteractiveParameterTraits::create (i, f, this));

        if (!interactiveParameter_.present ())
        {
          this->interactiveParameter_.set (::std::move (r));
          continue;
        }
      }

      // gesture
      //
      if (n.name () == "gesture" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< GestureType > r (
          GestureTraits::create (i, f, this));

        if (!gesture_.present ())
        {
          this->gesture_.set (::std::move (r));
          continue;
        }
      }

      // project
      //
      if (n.name () == "project" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ProjectType > r (
          ProjectTraits::create (i, f, this));

        if (!project_.present ())
        {
          this->project_.set (::std::move (r));
          continue;
        }
      }

      // hotKeys
      //
      if (n.name () == "hotKeys" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< HotKeysType > r (
          HotKeysTraits::create (i, f, this));

        if (!hotKeys_.present ())
        {
          this->hotKeys_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!visual_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "visual",
        "");
    }

    if (!dragger_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "dragger",
        "");
    }

    if (!interactiveParameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "interactiveParameter",
        "");
    }

    if (!gesture_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "gesture",
        "");
    }

    if (!project_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "project",
        "");
    }

    if (!hotKeys_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "hotKeys",
        "");
    }
  }

  Root* Root::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Root (*this, f, c);
  }

  Root& Root::
  operator= (const Root& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->visual_ = x.visual_;
      this->dragger_ = x.dragger_;
      this->interactiveParameter_ = x.interactiveParameter_;
      this->gesture_ = x.gesture_;
      this->project_ = x.project_;
      this->hotKeys_ = x.hotKeys_;
    }

    return *this;
  }

  Root::
  ~Root ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace prf
{
  ::std::unique_ptr< ::prf::Root >
  root (const ::std::string& u,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::prf::Root > (
      ::prf::root (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::prf::Root >
  root (const ::std::string& u,
        ::xml_schema::ErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::prf::Root > (
      ::prf::root (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::prf::Root >
  root (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::prf::Root > (
      ::prf::root (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::prf::Root >
  root (::std::istream& is,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::prf::root (isrc, f, p);
  }

  ::std::unique_ptr< ::prf::Root >
  root (::std::istream& is,
        ::xml_schema::ErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::prf::root (isrc, h, f, p);
  }

  ::std::unique_ptr< ::prf::Root >
  root (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::prf::root (isrc, h, f, p);
  }

  ::std::unique_ptr< ::prf::Root >
  root (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::prf::root (isrc, f, p);
  }

  ::std::unique_ptr< ::prf::Root >
  root (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::ErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::prf::root (isrc, h, f, p);
  }

  ::std::unique_ptr< ::prf::Root >
  root (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::prf::root (isrc, h, f, p);
  }

  ::std::unique_ptr< ::prf::Root >
  root (::xercesc::InputSource& i,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::prf::Root > (
      ::prf::root (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::prf::Root >
  root (::xercesc::InputSource& i,
        ::xml_schema::ErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::prf::Root > (
      ::prf::root (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::prf::Root >
  root (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::prf::Root > (
      ::prf::root (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::prf::Root >
  root (const ::xercesc::DOMDocument& doc,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::prf::Root > (
        ::prf::root (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "root" &&
        n.namespace_ () == "")
    {
      ::std::unique_ptr< ::prf::Root > r (
        ::xsd::cxx::tree::traits< ::prf::Root, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "root",
      "");
  }

  ::std::unique_ptr< ::prf::Root >
  root (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "root" &&
        n.namespace_ () == "")
    {
      ::std::unique_ptr< ::prf::Root > r (
        ::xsd::cxx::tree::traits< ::prf::Root, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "root",
      "");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace prf
{
  void
  operator<< (::xercesc::DOMElement& e, const DecPositive& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DecPositive& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const DecPositive& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Mesh& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // linearDeflection
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "linearDeflection",
          e));

      s << i.linearDeflection ();
    }

    // angularDeflection
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "angularDeflection",
          e));

      s << i.angularDeflection ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Display& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // showHiddenLines
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "showHiddenLines",
          e));

      s << i.showHiddenLines ();
    }

    // showCurrentSystem
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "showCurrentSystem",
          e));

      s << i.showCurrentSystem ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Visual& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // mesh
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mesh",
          e));

      s << i.mesh ();
    }

    // display
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "display",
          e));

      s << i.display ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Dragger& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // triggerUpdateOnFinish
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "triggerUpdateOnFinish",
          e));

      s << i.triggerUpdateOnFinish ();
    }

    // linearIncrement
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "linearIncrement",
          e));

      s << i.linearIncrement ();
    }

    // angularIncrement
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "angularIncrement",
          e));

      s << i.angularIncrement ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InteractiveParameter& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // characterSize
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "characterSize",
          e));

      s << i.characterSize ();
    }

    // arrowWidth
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "arrowWidth",
          e));

      s << i.arrowWidth ();
    }

    // arrowHeight
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "arrowHeight",
          e));

      s << i.arrowHeight ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Gesture& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // animationSeconds
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "animationSeconds",
          e));

      s << i.animationSeconds ();
    }

    // iconRadius
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "iconRadius",
          e));

      s << i.iconRadius ();
    }

    // includeAngle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "includeAngle",
          e));

      s << i.includeAngle ();
    }

    // spreadFactor
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spreadFactor",
          e));

      s << i.spreadFactor ();
    }

    // sprayFactor
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sprayFactor",
          e));

      s << i.sprayFactor ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RecentProjects& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Entry
    //
    for (RecentProjects::EntryConstIterator
         b (i.Entry ().begin ()), n (i.Entry ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Entry",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Project& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // basePath
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "basePath",
          e));

      s << i.basePath ();
    }

    // gitName
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gitName",
          e));

      s << i.gitName ();
    }

    // gitEmail
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gitEmail",
          e));

      s << i.gitEmail ();
    }

    // recentProjects
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "recentProjects",
          e));

      s << i.recentProjects ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpaceballButton& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // number
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "number",
          e));

      s << i.number ();
    }

    // mask
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mask",
          e));

      s << i.mask ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpaceballButtons& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // array
    //
    for (SpaceballButtons::ArrayConstIterator
         b (i.array ().begin ()), n (i.array ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "array",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HotKeys& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // spaceballButtons
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spaceballButtons",
          e));

      s << i.spaceballButtons ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Root& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // visual
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "visual",
          e));

      s << i.visual ();
    }

    // dragger
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dragger",
          e));

      s << i.dragger ();
    }

    // interactiveParameter
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "interactiveParameter",
          e));

      s << i.interactiveParameter ();
    }

    // gesture
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gesture",
          e));

      s << i.gesture ();
    }

    // project
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "project",
          e));

      s << i.project ();
    }

    // hotKeys
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hotKeys",
          e));

      s << i.hotKeys ();
    }
  }

  void
  root (::std::ostream& o,
        const ::prf::Root& s,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::prf::root (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  root (::std::ostream& o,
        const ::prf::Root& s,
        ::xml_schema::ErrorHandler& h,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::prf::root (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  root (::std::ostream& o,
        const ::prf::Root& s,
        ::xercesc::DOMErrorHandler& h,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::prf::root (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  root (::xercesc::XMLFormatTarget& t,
        const ::prf::Root& s,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::prf::root (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  root (::xercesc::XMLFormatTarget& t,
        const ::prf::Root& s,
        ::xml_schema::ErrorHandler& h,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::prf::root (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  root (::xercesc::XMLFormatTarget& t,
        const ::prf::Root& s,
        ::xercesc::DOMErrorHandler& h,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::prf::root (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  root (::xercesc::DOMDocument& d,
        const ::prf::Root& s,
        ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "root" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "root",
        "");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  root (const ::prf::Root& s,
        const ::xml_schema::NamespaceInfomap& m,
        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "root",
        "",
        m, f));

    ::prf::root (*d, s, f);
    return d;
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


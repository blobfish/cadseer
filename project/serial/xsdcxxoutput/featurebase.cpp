// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "featurebase.h"

namespace prj
{
  namespace srl
  {
    // Parameter
    // 

    const Parameter::NameType& Parameter::
    name () const
    {
      return this->name_.get ();
    }

    Parameter::NameType& Parameter::
    name ()
    {
      return this->name_.get ();
    }

    void Parameter::
    name (const NameType& x)
    {
      this->name_.set (x);
    }

    void Parameter::
    name (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const Parameter::NameType& Parameter::
    name_default_value ()
    {
      return name_default_value_;
    }

    const Parameter::ConstantType& Parameter::
    constant () const
    {
      return this->constant_.get ();
    }

    Parameter::ConstantType& Parameter::
    constant ()
    {
      return this->constant_.get ();
    }

    void Parameter::
    constant (const ConstantType& x)
    {
      this->constant_.set (x);
    }

    Parameter::ConstantType Parameter::
    constant_default_value ()
    {
      return ConstantType (true);
    }

    const Parameter::ValueType& Parameter::
    value () const
    {
      return this->value_.get ();
    }

    Parameter::ValueType& Parameter::
    value ()
    {
      return this->value_.get ();
    }

    void Parameter::
    value (const ValueType& x)
    {
      this->value_.set (x);
    }

    Parameter::ValueType Parameter::
    value_default_value ()
    {
      return ValueType (::std::numeric_limits< ::xml_schema::Double >::quiet_NaN ());
    }


    // EvolveRecord
    // 

    const EvolveRecord::IdInType& EvolveRecord::
    idIn () const
    {
      return this->idIn_.get ();
    }

    EvolveRecord::IdInType& EvolveRecord::
    idIn ()
    {
      return this->idIn_.get ();
    }

    void EvolveRecord::
    idIn (const IdInType& x)
    {
      this->idIn_.set (x);
    }

    void EvolveRecord::
    idIn (::std::unique_ptr< IdInType > x)
    {
      this->idIn_.set (std::move (x));
    }

    const EvolveRecord::IdInType& EvolveRecord::
    idIn_default_value ()
    {
      return idIn_default_value_;
    }

    const EvolveRecord::IdOutType& EvolveRecord::
    idOut () const
    {
      return this->idOut_.get ();
    }

    EvolveRecord::IdOutType& EvolveRecord::
    idOut ()
    {
      return this->idOut_.get ();
    }

    void EvolveRecord::
    idOut (const IdOutType& x)
    {
      this->idOut_.set (x);
    }

    void EvolveRecord::
    idOut (::std::unique_ptr< IdOutType > x)
    {
      this->idOut_.set (std::move (x));
    }

    const EvolveRecord::IdOutType& EvolveRecord::
    idOut_default_value ()
    {
      return idOut_default_value_;
    }


    // EvolveContainer
    // 

    const EvolveContainer::EvolveRecordSequence& EvolveContainer::
    evolveRecord () const
    {
      return this->evolveRecord_;
    }

    EvolveContainer::EvolveRecordSequence& EvolveContainer::
    evolveRecord ()
    {
      return this->evolveRecord_;
    }

    void EvolveContainer::
    evolveRecord (const EvolveRecordSequence& s)
    {
      this->evolveRecord_ = s;
    }


    // ShapeIdRecord
    // 

    const ShapeIdRecord::IdType& ShapeIdRecord::
    id () const
    {
      return this->id_.get ();
    }

    ShapeIdRecord::IdType& ShapeIdRecord::
    id ()
    {
      return this->id_.get ();
    }

    void ShapeIdRecord::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void ShapeIdRecord::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const ShapeIdRecord::IdType& ShapeIdRecord::
    id_default_value ()
    {
      return id_default_value_;
    }

    const ShapeIdRecord::ShapeOffsetType& ShapeIdRecord::
    shapeOffset () const
    {
      return this->shapeOffset_.get ();
    }

    ShapeIdRecord::ShapeOffsetType& ShapeIdRecord::
    shapeOffset ()
    {
      return this->shapeOffset_.get ();
    }

    void ShapeIdRecord::
    shapeOffset (const ShapeOffsetType& x)
    {
      this->shapeOffset_.set (x);
    }

    ShapeIdRecord::ShapeOffsetType ShapeIdRecord::
    shapeOffset_default_value ()
    {
      return ShapeOffsetType (18446744073709551615ULL);
    }


    // ShapeIdContainer
    // 

    const ShapeIdContainer::ShapeIdRecordSequence& ShapeIdContainer::
    shapeIdRecord () const
    {
      return this->shapeIdRecord_;
    }

    ShapeIdContainer::ShapeIdRecordSequence& ShapeIdContainer::
    shapeIdRecord ()
    {
      return this->shapeIdRecord_;
    }

    void ShapeIdContainer::
    shapeIdRecord (const ShapeIdRecordSequence& s)
    {
      this->shapeIdRecord_ = s;
    }


    // FeatureTagRecord
    // 

    const FeatureTagRecord::IdType& FeatureTagRecord::
    id () const
    {
      return this->id_.get ();
    }

    FeatureTagRecord::IdType& FeatureTagRecord::
    id ()
    {
      return this->id_.get ();
    }

    void FeatureTagRecord::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void FeatureTagRecord::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const FeatureTagRecord::IdType& FeatureTagRecord::
    id_default_value ()
    {
      return id_default_value_;
    }

    const FeatureTagRecord::TagType& FeatureTagRecord::
    tag () const
    {
      return this->tag_.get ();
    }

    FeatureTagRecord::TagType& FeatureTagRecord::
    tag ()
    {
      return this->tag_.get ();
    }

    void FeatureTagRecord::
    tag (const TagType& x)
    {
      this->tag_.set (x);
    }

    void FeatureTagRecord::
    tag (::std::unique_ptr< TagType > x)
    {
      this->tag_.set (std::move (x));
    }

    const FeatureTagRecord::TagType& FeatureTagRecord::
    tag_default_value ()
    {
      return tag_default_value_;
    }


    // FeatureTagContainer
    // 

    const FeatureTagContainer::FeatureTagRecordSequence& FeatureTagContainer::
    featureTagRecord () const
    {
      return this->featureTagRecord_;
    }

    FeatureTagContainer::FeatureTagRecordSequence& FeatureTagContainer::
    featureTagRecord ()
    {
      return this->featureTagRecord_;
    }

    void FeatureTagContainer::
    featureTagRecord (const FeatureTagRecordSequence& s)
    {
      this->featureTagRecord_ = s;
    }


    // IdSet
    // 

    const IdSet::IdSequence& IdSet::
    id () const
    {
      return this->id_;
    }

    IdSet::IdSequence& IdSet::
    id ()
    {
      return this->id_;
    }

    void IdSet::
    id (const IdSequence& s)
    {
      this->id_ = s;
    }

    const IdSet::IdType& IdSet::
    id_default_value ()
    {
      return id_default_value_;
    }


    // DerivedRecord
    // 

    const DerivedRecord::IdSetType& DerivedRecord::
    idSet () const
    {
      return this->idSet_.get ();
    }

    DerivedRecord::IdSetType& DerivedRecord::
    idSet ()
    {
      return this->idSet_.get ();
    }

    void DerivedRecord::
    idSet (const IdSetType& x)
    {
      this->idSet_.set (x);
    }

    void DerivedRecord::
    idSet (::std::unique_ptr< IdSetType > x)
    {
      this->idSet_.set (std::move (x));
    }

    const DerivedRecord::IdType& DerivedRecord::
    id () const
    {
      return this->id_.get ();
    }

    DerivedRecord::IdType& DerivedRecord::
    id ()
    {
      return this->id_.get ();
    }

    void DerivedRecord::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void DerivedRecord::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const DerivedRecord::IdType& DerivedRecord::
    id_default_value ()
    {
      return id_default_value_;
    }


    // DerivedContainer
    // 

    const DerivedContainer::DerivedRecordSequence& DerivedContainer::
    derivedRecord () const
    {
      return this->derivedRecord_;
    }

    DerivedContainer::DerivedRecordSequence& DerivedContainer::
    derivedRecord ()
    {
      return this->derivedRecord_;
    }

    void DerivedContainer::
    derivedRecord (const DerivedRecordSequence& s)
    {
      this->derivedRecord_ = s;
    }


    // SeerShape
    // 

    const SeerShape::RootShapeIdType& SeerShape::
    rootShapeId () const
    {
      return this->rootShapeId_.get ();
    }

    SeerShape::RootShapeIdType& SeerShape::
    rootShapeId ()
    {
      return this->rootShapeId_.get ();
    }

    void SeerShape::
    rootShapeId (const RootShapeIdType& x)
    {
      this->rootShapeId_.set (x);
    }

    void SeerShape::
    rootShapeId (::std::unique_ptr< RootShapeIdType > x)
    {
      this->rootShapeId_.set (std::move (x));
    }

    const SeerShape::RootShapeIdType& SeerShape::
    rootShapeId_default_value ()
    {
      return rootShapeId_default_value_;
    }

    const SeerShape::ShapeIdContainerType& SeerShape::
    shapeIdContainer () const
    {
      return this->shapeIdContainer_.get ();
    }

    SeerShape::ShapeIdContainerType& SeerShape::
    shapeIdContainer ()
    {
      return this->shapeIdContainer_.get ();
    }

    void SeerShape::
    shapeIdContainer (const ShapeIdContainerType& x)
    {
      this->shapeIdContainer_.set (x);
    }

    void SeerShape::
    shapeIdContainer (::std::unique_ptr< ShapeIdContainerType > x)
    {
      this->shapeIdContainer_.set (std::move (x));
    }

    const SeerShape::EvolveContainerType& SeerShape::
    evolveContainer () const
    {
      return this->evolveContainer_.get ();
    }

    SeerShape::EvolveContainerType& SeerShape::
    evolveContainer ()
    {
      return this->evolveContainer_.get ();
    }

    void SeerShape::
    evolveContainer (const EvolveContainerType& x)
    {
      this->evolveContainer_.set (x);
    }

    void SeerShape::
    evolveContainer (::std::unique_ptr< EvolveContainerType > x)
    {
      this->evolveContainer_.set (std::move (x));
    }

    const SeerShape::FeatureTagContainerType& SeerShape::
    featureTagContainer () const
    {
      return this->featureTagContainer_.get ();
    }

    SeerShape::FeatureTagContainerType& SeerShape::
    featureTagContainer ()
    {
      return this->featureTagContainer_.get ();
    }

    void SeerShape::
    featureTagContainer (const FeatureTagContainerType& x)
    {
      this->featureTagContainer_.set (x);
    }

    void SeerShape::
    featureTagContainer (::std::unique_ptr< FeatureTagContainerType > x)
    {
      this->featureTagContainer_.set (std::move (x));
    }

    const SeerShape::DerivedContainerType& SeerShape::
    derivedContainer () const
    {
      return this->derivedContainer_.get ();
    }

    SeerShape::DerivedContainerType& SeerShape::
    derivedContainer ()
    {
      return this->derivedContainer_.get ();
    }

    void SeerShape::
    derivedContainer (const DerivedContainerType& x)
    {
      this->derivedContainer_.set (x);
    }

    void SeerShape::
    derivedContainer (::std::unique_ptr< DerivedContainerType > x)
    {
      this->derivedContainer_.set (std::move (x));
    }


    // FeatureBase
    // 

    const FeatureBase::NameType& FeatureBase::
    name () const
    {
      return this->name_.get ();
    }

    FeatureBase::NameType& FeatureBase::
    name ()
    {
      return this->name_.get ();
    }

    void FeatureBase::
    name (const NameType& x)
    {
      this->name_.set (x);
    }

    void FeatureBase::
    name (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const FeatureBase::NameType& FeatureBase::
    name_default_value ()
    {
      return name_default_value_;
    }

    const FeatureBase::IdType& FeatureBase::
    id () const
    {
      return this->id_.get ();
    }

    FeatureBase::IdType& FeatureBase::
    id ()
    {
      return this->id_.get ();
    }

    void FeatureBase::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void FeatureBase::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const FeatureBase::IdType& FeatureBase::
    id_default_value ()
    {
      return id_default_value_;
    }

    const FeatureBase::SeerShapeType& FeatureBase::
    seerShape () const
    {
      return this->seerShape_.get ();
    }

    FeatureBase::SeerShapeType& FeatureBase::
    seerShape ()
    {
      return this->seerShape_.get ();
    }

    void FeatureBase::
    seerShape (const SeerShapeType& x)
    {
      this->seerShape_.set (x);
    }

    void FeatureBase::
    seerShape (::std::unique_ptr< SeerShapeType > x)
    {
      this->seerShape_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace prj
{
  namespace srl
  {
    // Parameter
    //

    const Parameter::NameType Parameter::name_default_value_ (
      "Name");

    Parameter::
    Parameter (const NameType& name,
               const ConstantType& constant,
               const ValueType& value)
    : ::xml_schema::Type (),
      name_ (name, this),
      constant_ (constant, this),
      value_ (value, this)
    {
    }

    Parameter::
    Parameter (const Parameter& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      name_ (x.name_, f, this),
      constant_ (x.constant_, f, this),
      value_ (x.value_, f, this)
    {
    }

    Parameter::
    Parameter (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      name_ (this),
      constant_ (this),
      value_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Parameter::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // name
        //
        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< NameType > r (
            NameTraits::create (i, f, this));

          if (!name_.present ())
          {
            this->name_.set (::std::move (r));
            continue;
          }
        }

        // constant
        //
        if (n.name () == "constant" && n.namespace_ ().empty ())
        {
          if (!constant_.present ())
          {
            this->constant_.set (ConstantTraits::create (i, f, this));
            continue;
          }
        }

        // value
        //
        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          if (!value_.present ())
          {
            this->value_.set (ValueTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!constant_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "constant",
          "");
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "value",
          "");
      }
    }

    Parameter* Parameter::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Parameter (*this, f, c);
    }

    Parameter& Parameter::
    operator= (const Parameter& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->name_ = x.name_;
        this->constant_ = x.constant_;
        this->value_ = x.value_;
      }

      return *this;
    }

    Parameter::
    ~Parameter ()
    {
    }

    // EvolveRecord
    //

    const EvolveRecord::IdInType EvolveRecord::idIn_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    const EvolveRecord::IdOutType EvolveRecord::idOut_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    EvolveRecord::
    EvolveRecord (const IdInType& idIn,
                  const IdOutType& idOut)
    : ::xml_schema::Type (),
      idIn_ (idIn, this),
      idOut_ (idOut, this)
    {
    }

    EvolveRecord::
    EvolveRecord (const EvolveRecord& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      idIn_ (x.idIn_, f, this),
      idOut_ (x.idOut_, f, this)
    {
    }

    EvolveRecord::
    EvolveRecord (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      idIn_ (this),
      idOut_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EvolveRecord::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // idIn
        //
        if (n.name () == "idIn" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdInType > r (
            IdInTraits::create (i, f, this));

          if (!idIn_.present ())
          {
            this->idIn_.set (::std::move (r));
            continue;
          }
        }

        // idOut
        //
        if (n.name () == "idOut" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdOutType > r (
            IdOutTraits::create (i, f, this));

          if (!idOut_.present ())
          {
            this->idOut_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!idIn_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "idIn",
          "");
      }

      if (!idOut_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "idOut",
          "");
      }
    }

    EvolveRecord* EvolveRecord::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EvolveRecord (*this, f, c);
    }

    EvolveRecord& EvolveRecord::
    operator= (const EvolveRecord& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->idIn_ = x.idIn_;
        this->idOut_ = x.idOut_;
      }

      return *this;
    }

    EvolveRecord::
    ~EvolveRecord ()
    {
    }

    // EvolveContainer
    //

    EvolveContainer::
    EvolveContainer ()
    : ::xml_schema::Type (),
      evolveRecord_ (this)
    {
    }

    EvolveContainer::
    EvolveContainer (const EvolveContainer& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      evolveRecord_ (x.evolveRecord_, f, this)
    {
    }

    EvolveContainer::
    EvolveContainer (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      evolveRecord_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EvolveContainer::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // evolveRecord
        //
        if (n.name () == "evolveRecord" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< EvolveRecordType > r (
            EvolveRecordTraits::create (i, f, this));

          this->evolveRecord_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    EvolveContainer* EvolveContainer::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EvolveContainer (*this, f, c);
    }

    EvolveContainer& EvolveContainer::
    operator= (const EvolveContainer& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->evolveRecord_ = x.evolveRecord_;
      }

      return *this;
    }

    EvolveContainer::
    ~EvolveContainer ()
    {
    }

    // ShapeIdRecord
    //

    const ShapeIdRecord::IdType ShapeIdRecord::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    ShapeIdRecord::
    ShapeIdRecord (const IdType& id,
                   const ShapeOffsetType& shapeOffset)
    : ::xml_schema::Type (),
      id_ (id, this),
      shapeOffset_ (shapeOffset, this)
    {
    }

    ShapeIdRecord::
    ShapeIdRecord (const ShapeIdRecord& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this),
      shapeOffset_ (x.shapeOffset_, f, this)
    {
    }

    ShapeIdRecord::
    ShapeIdRecord (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this),
      shapeOffset_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ShapeIdRecord::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          if (!id_.present ())
          {
            this->id_.set (::std::move (r));
            continue;
          }
        }

        // shapeOffset
        //
        if (n.name () == "shapeOffset" && n.namespace_ ().empty ())
        {
          if (!shapeOffset_.present ())
          {
            this->shapeOffset_.set (ShapeOffsetTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!shapeOffset_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "shapeOffset",
          "");
      }
    }

    ShapeIdRecord* ShapeIdRecord::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ShapeIdRecord (*this, f, c);
    }

    ShapeIdRecord& ShapeIdRecord::
    operator= (const ShapeIdRecord& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
        this->shapeOffset_ = x.shapeOffset_;
      }

      return *this;
    }

    ShapeIdRecord::
    ~ShapeIdRecord ()
    {
    }

    // ShapeIdContainer
    //

    ShapeIdContainer::
    ShapeIdContainer ()
    : ::xml_schema::Type (),
      shapeIdRecord_ (this)
    {
    }

    ShapeIdContainer::
    ShapeIdContainer (const ShapeIdContainer& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      shapeIdRecord_ (x.shapeIdRecord_, f, this)
    {
    }

    ShapeIdContainer::
    ShapeIdContainer (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      shapeIdRecord_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ShapeIdContainer::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // shapeIdRecord
        //
        if (n.name () == "shapeIdRecord" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ShapeIdRecordType > r (
            ShapeIdRecordTraits::create (i, f, this));

          this->shapeIdRecord_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    ShapeIdContainer* ShapeIdContainer::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ShapeIdContainer (*this, f, c);
    }

    ShapeIdContainer& ShapeIdContainer::
    operator= (const ShapeIdContainer& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->shapeIdRecord_ = x.shapeIdRecord_;
      }

      return *this;
    }

    ShapeIdContainer::
    ~ShapeIdContainer ()
    {
    }

    // FeatureTagRecord
    //

    const FeatureTagRecord::IdType FeatureTagRecord::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    const FeatureTagRecord::TagType FeatureTagRecord::tag_default_value_ (
      "");

    FeatureTagRecord::
    FeatureTagRecord (const IdType& id,
                      const TagType& tag)
    : ::xml_schema::Type (),
      id_ (id, this),
      tag_ (tag, this)
    {
    }

    FeatureTagRecord::
    FeatureTagRecord (const FeatureTagRecord& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this),
      tag_ (x.tag_, f, this)
    {
    }

    FeatureTagRecord::
    FeatureTagRecord (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this),
      tag_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureTagRecord::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          if (!id_.present ())
          {
            this->id_.set (::std::move (r));
            continue;
          }
        }

        // tag
        //
        if (n.name () == "tag" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< TagType > r (
            TagTraits::create (i, f, this));

          if (!tag_.present ())
          {
            this->tag_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!tag_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "tag",
          "");
      }
    }

    FeatureTagRecord* FeatureTagRecord::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FeatureTagRecord (*this, f, c);
    }

    FeatureTagRecord& FeatureTagRecord::
    operator= (const FeatureTagRecord& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
        this->tag_ = x.tag_;
      }

      return *this;
    }

    FeatureTagRecord::
    ~FeatureTagRecord ()
    {
    }

    // FeatureTagContainer
    //

    FeatureTagContainer::
    FeatureTagContainer ()
    : ::xml_schema::Type (),
      featureTagRecord_ (this)
    {
    }

    FeatureTagContainer::
    FeatureTagContainer (const FeatureTagContainer& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      featureTagRecord_ (x.featureTagRecord_, f, this)
    {
    }

    FeatureTagContainer::
    FeatureTagContainer (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      featureTagRecord_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureTagContainer::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // featureTagRecord
        //
        if (n.name () == "featureTagRecord" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< FeatureTagRecordType > r (
            FeatureTagRecordTraits::create (i, f, this));

          this->featureTagRecord_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    FeatureTagContainer* FeatureTagContainer::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FeatureTagContainer (*this, f, c);
    }

    FeatureTagContainer& FeatureTagContainer::
    operator= (const FeatureTagContainer& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->featureTagRecord_ = x.featureTagRecord_;
      }

      return *this;
    }

    FeatureTagContainer::
    ~FeatureTagContainer ()
    {
    }

    // IdSet
    //

    const IdSet::IdType IdSet::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    IdSet::
    IdSet ()
    : ::xml_schema::Type (),
      id_ (this)
    {
    }

    IdSet::
    IdSet (const IdSet& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this)
    {
    }

    IdSet::
    IdSet (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void IdSet::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->id_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    IdSet* IdSet::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IdSet (*this, f, c);
    }

    IdSet& IdSet::
    operator= (const IdSet& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
      }

      return *this;
    }

    IdSet::
    ~IdSet ()
    {
    }

    // DerivedRecord
    //

    const DerivedRecord::IdType DerivedRecord::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    DerivedRecord::
    DerivedRecord (const IdSetType& idSet,
                   const IdType& id)
    : ::xml_schema::Type (),
      idSet_ (idSet, this),
      id_ (id, this)
    {
    }

    DerivedRecord::
    DerivedRecord (::std::unique_ptr< IdSetType > idSet,
                   const IdType& id)
    : ::xml_schema::Type (),
      idSet_ (std::move (idSet), this),
      id_ (id, this)
    {
    }

    DerivedRecord::
    DerivedRecord (const DerivedRecord& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      idSet_ (x.idSet_, f, this),
      id_ (x.id_, f, this)
    {
    }

    DerivedRecord::
    DerivedRecord (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      idSet_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DerivedRecord::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // idSet
        //
        if (n.name () == "idSet" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdSetType > r (
            IdSetTraits::create (i, f, this));

          if (!idSet_.present ())
          {
            this->idSet_.set (::std::move (r));
            continue;
          }
        }

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          if (!id_.present ())
          {
            this->id_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!idSet_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "idSet",
          "");
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }
    }

    DerivedRecord* DerivedRecord::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DerivedRecord (*this, f, c);
    }

    DerivedRecord& DerivedRecord::
    operator= (const DerivedRecord& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->idSet_ = x.idSet_;
        this->id_ = x.id_;
      }

      return *this;
    }

    DerivedRecord::
    ~DerivedRecord ()
    {
    }

    // DerivedContainer
    //

    DerivedContainer::
    DerivedContainer ()
    : ::xml_schema::Type (),
      derivedRecord_ (this)
    {
    }

    DerivedContainer::
    DerivedContainer (const DerivedContainer& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      derivedRecord_ (x.derivedRecord_, f, this)
    {
    }

    DerivedContainer::
    DerivedContainer (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      derivedRecord_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DerivedContainer::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // derivedRecord
        //
        if (n.name () == "derivedRecord" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< DerivedRecordType > r (
            DerivedRecordTraits::create (i, f, this));

          this->derivedRecord_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    DerivedContainer* DerivedContainer::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DerivedContainer (*this, f, c);
    }

    DerivedContainer& DerivedContainer::
    operator= (const DerivedContainer& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->derivedRecord_ = x.derivedRecord_;
      }

      return *this;
    }

    DerivedContainer::
    ~DerivedContainer ()
    {
    }

    // SeerShape
    //

    const SeerShape::RootShapeIdType SeerShape::rootShapeId_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    SeerShape::
    SeerShape (const RootShapeIdType& rootShapeId,
               const ShapeIdContainerType& shapeIdContainer,
               const EvolveContainerType& evolveContainer,
               const FeatureTagContainerType& featureTagContainer,
               const DerivedContainerType& derivedContainer)
    : ::xml_schema::Type (),
      rootShapeId_ (rootShapeId, this),
      shapeIdContainer_ (shapeIdContainer, this),
      evolveContainer_ (evolveContainer, this),
      featureTagContainer_ (featureTagContainer, this),
      derivedContainer_ (derivedContainer, this)
    {
    }

    SeerShape::
    SeerShape (const RootShapeIdType& rootShapeId,
               ::std::unique_ptr< ShapeIdContainerType > shapeIdContainer,
               ::std::unique_ptr< EvolveContainerType > evolveContainer,
               ::std::unique_ptr< FeatureTagContainerType > featureTagContainer,
               ::std::unique_ptr< DerivedContainerType > derivedContainer)
    : ::xml_schema::Type (),
      rootShapeId_ (rootShapeId, this),
      shapeIdContainer_ (std::move (shapeIdContainer), this),
      evolveContainer_ (std::move (evolveContainer), this),
      featureTagContainer_ (std::move (featureTagContainer), this),
      derivedContainer_ (std::move (derivedContainer), this)
    {
    }

    SeerShape::
    SeerShape (const SeerShape& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      rootShapeId_ (x.rootShapeId_, f, this),
      shapeIdContainer_ (x.shapeIdContainer_, f, this),
      evolveContainer_ (x.evolveContainer_, f, this),
      featureTagContainer_ (x.featureTagContainer_, f, this),
      derivedContainer_ (x.derivedContainer_, f, this)
    {
    }

    SeerShape::
    SeerShape (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      rootShapeId_ (this),
      shapeIdContainer_ (this),
      evolveContainer_ (this),
      featureTagContainer_ (this),
      derivedContainer_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SeerShape::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // rootShapeId
        //
        if (n.name () == "rootShapeId" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< RootShapeIdType > r (
            RootShapeIdTraits::create (i, f, this));

          if (!rootShapeId_.present ())
          {
            this->rootShapeId_.set (::std::move (r));
            continue;
          }
        }

        // shapeIdContainer
        //
        if (n.name () == "shapeIdContainer" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ShapeIdContainerType > r (
            ShapeIdContainerTraits::create (i, f, this));

          if (!shapeIdContainer_.present ())
          {
            this->shapeIdContainer_.set (::std::move (r));
            continue;
          }
        }

        // evolveContainer
        //
        if (n.name () == "evolveContainer" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< EvolveContainerType > r (
            EvolveContainerTraits::create (i, f, this));

          if (!evolveContainer_.present ())
          {
            this->evolveContainer_.set (::std::move (r));
            continue;
          }
        }

        // featureTagContainer
        //
        if (n.name () == "featureTagContainer" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< FeatureTagContainerType > r (
            FeatureTagContainerTraits::create (i, f, this));

          if (!featureTagContainer_.present ())
          {
            this->featureTagContainer_.set (::std::move (r));
            continue;
          }
        }

        // derivedContainer
        //
        if (n.name () == "derivedContainer" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< DerivedContainerType > r (
            DerivedContainerTraits::create (i, f, this));

          if (!derivedContainer_.present ())
          {
            this->derivedContainer_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!rootShapeId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "rootShapeId",
          "");
      }

      if (!shapeIdContainer_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "shapeIdContainer",
          "");
      }

      if (!evolveContainer_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "evolveContainer",
          "");
      }

      if (!featureTagContainer_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "featureTagContainer",
          "");
      }

      if (!derivedContainer_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "derivedContainer",
          "");
      }
    }

    SeerShape* SeerShape::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SeerShape (*this, f, c);
    }

    SeerShape& SeerShape::
    operator= (const SeerShape& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->rootShapeId_ = x.rootShapeId_;
        this->shapeIdContainer_ = x.shapeIdContainer_;
        this->evolveContainer_ = x.evolveContainer_;
        this->featureTagContainer_ = x.featureTagContainer_;
        this->derivedContainer_ = x.derivedContainer_;
      }

      return *this;
    }

    SeerShape::
    ~SeerShape ()
    {
    }

    // FeatureBase
    //

    const FeatureBase::NameType FeatureBase::name_default_value_ (
      "Empty");

    const FeatureBase::IdType FeatureBase::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    FeatureBase::
    FeatureBase (const NameType& name,
                 const IdType& id,
                 const SeerShapeType& seerShape)
    : ::xml_schema::Type (),
      name_ (name, this),
      id_ (id, this),
      seerShape_ (seerShape, this)
    {
    }

    FeatureBase::
    FeatureBase (const NameType& name,
                 const IdType& id,
                 ::std::unique_ptr< SeerShapeType > seerShape)
    : ::xml_schema::Type (),
      name_ (name, this),
      id_ (id, this),
      seerShape_ (std::move (seerShape), this)
    {
    }

    FeatureBase::
    FeatureBase (const FeatureBase& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      name_ (x.name_, f, this),
      id_ (x.id_, f, this),
      seerShape_ (x.seerShape_, f, this)
    {
    }

    FeatureBase::
    FeatureBase (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      name_ (this),
      id_ (this),
      seerShape_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureBase::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // name
        //
        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< NameType > r (
            NameTraits::create (i, f, this));

          if (!name_.present ())
          {
            this->name_.set (::std::move (r));
            continue;
          }
        }

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          if (!id_.present ())
          {
            this->id_.set (::std::move (r));
            continue;
          }
        }

        // seerShape
        //
        if (n.name () == "seerShape" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< SeerShapeType > r (
            SeerShapeTraits::create (i, f, this));

          if (!seerShape_.present ())
          {
            this->seerShape_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!seerShape_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "seerShape",
          "");
      }
    }

    FeatureBase* FeatureBase::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FeatureBase (*this, f, c);
    }

    FeatureBase& FeatureBase::
    operator= (const FeatureBase& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->name_ = x.name_;
        this->id_ = x.id_;
        this->seerShape_ = x.seerShape_;
      }

      return *this;
    }

    FeatureBase::
    ~FeatureBase ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace prj
{
  namespace srl
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace prj
{
  namespace srl
  {
    void
    operator<< (::xercesc::DOMElement& e, const Parameter& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // name
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "name",
            e));

        s << i.name ();
      }

      // constant
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "constant",
            e));

        s << i.constant ();
      }

      // value
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "value",
            e));

        s << ::xml_schema::AsDouble(i.value ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EvolveRecord& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // idIn
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "idIn",
            e));

        s << i.idIn ();
      }

      // idOut
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "idOut",
            e));

        s << i.idOut ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EvolveContainer& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // evolveRecord
      //
      for (EvolveContainer::EvolveRecordConstIterator
           b (i.evolveRecord ().begin ()), n (i.evolveRecord ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "evolveRecord",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ShapeIdRecord& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // id
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << i.id ();
      }

      // shapeOffset
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "shapeOffset",
            e));

        s << i.shapeOffset ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ShapeIdContainer& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // shapeIdRecord
      //
      for (ShapeIdContainer::ShapeIdRecordConstIterator
           b (i.shapeIdRecord ().begin ()), n (i.shapeIdRecord ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "shapeIdRecord",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureTagRecord& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // id
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << i.id ();
      }

      // tag
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "tag",
            e));

        s << i.tag ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureTagContainer& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // featureTagRecord
      //
      for (FeatureTagContainer::FeatureTagRecordConstIterator
           b (i.featureTagRecord ().begin ()), n (i.featureTagRecord ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "featureTagRecord",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IdSet& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // id
      //
      for (IdSet::IdConstIterator
           b (i.id ().begin ()), n (i.id ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DerivedRecord& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // idSet
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "idSet",
            e));

        s << i.idSet ();
      }

      // id
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DerivedContainer& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // derivedRecord
      //
      for (DerivedContainer::DerivedRecordConstIterator
           b (i.derivedRecord ().begin ()), n (i.derivedRecord ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "derivedRecord",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SeerShape& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // rootShapeId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "rootShapeId",
            e));

        s << i.rootShapeId ();
      }

      // shapeIdContainer
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "shapeIdContainer",
            e));

        s << i.shapeIdContainer ();
      }

      // evolveContainer
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "evolveContainer",
            e));

        s << i.evolveContainer ();
      }

      // featureTagContainer
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "featureTagContainer",
            e));

        s << i.featureTagContainer ();
      }

      // derivedContainer
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "derivedContainer",
            e));

        s << i.derivedContainer ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureBase& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // name
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "name",
            e));

        s << i.name ();
      }

      // id
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << i.id ();
      }

      // seerShape
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "seerShape",
            e));

        s << i.seerShape ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


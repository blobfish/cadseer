// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "featurebase.h"

namespace prj
{
  namespace srl
  {
    // Vec3d
    // 

    const Vec3d::XType& Vec3d::
    x () const
    {
      return this->x_.get ();
    }

    Vec3d::XType& Vec3d::
    x ()
    {
      return this->x_.get ();
    }

    void Vec3d::
    x (const XType& x)
    {
      this->x_.set (x);
    }

    Vec3d::XType Vec3d::
    x_default_value ()
    {
      return XType (::std::numeric_limits< ::xml_schema::Double >::quiet_NaN ());
    }

    const Vec3d::YType& Vec3d::
    y () const
    {
      return this->y_.get ();
    }

    Vec3d::YType& Vec3d::
    y ()
    {
      return this->y_.get ();
    }

    void Vec3d::
    y (const YType& x)
    {
      this->y_.set (x);
    }

    Vec3d::YType Vec3d::
    y_default_value ()
    {
      return YType (::std::numeric_limits< ::xml_schema::Double >::quiet_NaN ());
    }

    const Vec3d::ZType& Vec3d::
    z () const
    {
      return this->z_.get ();
    }

    Vec3d::ZType& Vec3d::
    z ()
    {
      return this->z_.get ();
    }

    void Vec3d::
    z (const ZType& x)
    {
      this->z_.set (x);
    }

    Vec3d::ZType Vec3d::
    z_default_value ()
    {
      return ZType (::std::numeric_limits< ::xml_schema::Double >::quiet_NaN ());
    }


    // Quat
    // 

    const Quat::XType& Quat::
    x () const
    {
      return this->x_.get ();
    }

    Quat::XType& Quat::
    x ()
    {
      return this->x_.get ();
    }

    void Quat::
    x (const XType& x)
    {
      this->x_.set (x);
    }

    Quat::XType Quat::
    x_default_value ()
    {
      return XType (::std::numeric_limits< ::xml_schema::Double >::quiet_NaN ());
    }

    const Quat::YType& Quat::
    y () const
    {
      return this->y_.get ();
    }

    Quat::YType& Quat::
    y ()
    {
      return this->y_.get ();
    }

    void Quat::
    y (const YType& x)
    {
      this->y_.set (x);
    }

    Quat::YType Quat::
    y_default_value ()
    {
      return YType (::std::numeric_limits< ::xml_schema::Double >::quiet_NaN ());
    }

    const Quat::ZType& Quat::
    z () const
    {
      return this->z_.get ();
    }

    Quat::ZType& Quat::
    z ()
    {
      return this->z_.get ();
    }

    void Quat::
    z (const ZType& x)
    {
      this->z_.set (x);
    }

    Quat::ZType Quat::
    z_default_value ()
    {
      return ZType (::std::numeric_limits< ::xml_schema::Double >::quiet_NaN ());
    }

    const Quat::WType& Quat::
    w () const
    {
      return this->w_.get ();
    }

    Quat::WType& Quat::
    w ()
    {
      return this->w_.get ();
    }

    void Quat::
    w (const WType& x)
    {
      this->w_.set (x);
    }

    Quat::WType Quat::
    w_default_value ()
    {
      return WType (::std::numeric_limits< ::xml_schema::Double >::quiet_NaN ());
    }


    // Matrixd
    // 

    const Matrixd::I0j0Type& Matrixd::
    i0j0 () const
    {
      return this->i0j0_.get ();
    }

    Matrixd::I0j0Type& Matrixd::
    i0j0 ()
    {
      return this->i0j0_.get ();
    }

    void Matrixd::
    i0j0 (const I0j0Type& x)
    {
      this->i0j0_.set (x);
    }

    Matrixd::I0j0Type Matrixd::
    i0j0_default_value ()
    {
      return I0j0Type (1.0);
    }

    const Matrixd::I0j1Type& Matrixd::
    i0j1 () const
    {
      return this->i0j1_.get ();
    }

    Matrixd::I0j1Type& Matrixd::
    i0j1 ()
    {
      return this->i0j1_.get ();
    }

    void Matrixd::
    i0j1 (const I0j1Type& x)
    {
      this->i0j1_.set (x);
    }

    Matrixd::I0j1Type Matrixd::
    i0j1_default_value ()
    {
      return I0j1Type (.0);
    }

    const Matrixd::I0j2Type& Matrixd::
    i0j2 () const
    {
      return this->i0j2_.get ();
    }

    Matrixd::I0j2Type& Matrixd::
    i0j2 ()
    {
      return this->i0j2_.get ();
    }

    void Matrixd::
    i0j2 (const I0j2Type& x)
    {
      this->i0j2_.set (x);
    }

    Matrixd::I0j2Type Matrixd::
    i0j2_default_value ()
    {
      return I0j2Type (.0);
    }

    const Matrixd::I0j3Type& Matrixd::
    i0j3 () const
    {
      return this->i0j3_.get ();
    }

    Matrixd::I0j3Type& Matrixd::
    i0j3 ()
    {
      return this->i0j3_.get ();
    }

    void Matrixd::
    i0j3 (const I0j3Type& x)
    {
      this->i0j3_.set (x);
    }

    Matrixd::I0j3Type Matrixd::
    i0j3_default_value ()
    {
      return I0j3Type (.0);
    }

    const Matrixd::I1j0Type& Matrixd::
    i1j0 () const
    {
      return this->i1j0_.get ();
    }

    Matrixd::I1j0Type& Matrixd::
    i1j0 ()
    {
      return this->i1j0_.get ();
    }

    void Matrixd::
    i1j0 (const I1j0Type& x)
    {
      this->i1j0_.set (x);
    }

    Matrixd::I1j0Type Matrixd::
    i1j0_default_value ()
    {
      return I1j0Type (.0);
    }

    const Matrixd::I1j1Type& Matrixd::
    i1j1 () const
    {
      return this->i1j1_.get ();
    }

    Matrixd::I1j1Type& Matrixd::
    i1j1 ()
    {
      return this->i1j1_.get ();
    }

    void Matrixd::
    i1j1 (const I1j1Type& x)
    {
      this->i1j1_.set (x);
    }

    Matrixd::I1j1Type Matrixd::
    i1j1_default_value ()
    {
      return I1j1Type (1.0);
    }

    const Matrixd::I1j2Type& Matrixd::
    i1j2 () const
    {
      return this->i1j2_.get ();
    }

    Matrixd::I1j2Type& Matrixd::
    i1j2 ()
    {
      return this->i1j2_.get ();
    }

    void Matrixd::
    i1j2 (const I1j2Type& x)
    {
      this->i1j2_.set (x);
    }

    Matrixd::I1j2Type Matrixd::
    i1j2_default_value ()
    {
      return I1j2Type (.0);
    }

    const Matrixd::I1j3Type& Matrixd::
    i1j3 () const
    {
      return this->i1j3_.get ();
    }

    Matrixd::I1j3Type& Matrixd::
    i1j3 ()
    {
      return this->i1j3_.get ();
    }

    void Matrixd::
    i1j3 (const I1j3Type& x)
    {
      this->i1j3_.set (x);
    }

    Matrixd::I1j3Type Matrixd::
    i1j3_default_value ()
    {
      return I1j3Type (.0);
    }

    const Matrixd::I2j0Type& Matrixd::
    i2j0 () const
    {
      return this->i2j0_.get ();
    }

    Matrixd::I2j0Type& Matrixd::
    i2j0 ()
    {
      return this->i2j0_.get ();
    }

    void Matrixd::
    i2j0 (const I2j0Type& x)
    {
      this->i2j0_.set (x);
    }

    Matrixd::I2j0Type Matrixd::
    i2j0_default_value ()
    {
      return I2j0Type (.0);
    }

    const Matrixd::I2j1Type& Matrixd::
    i2j1 () const
    {
      return this->i2j1_.get ();
    }

    Matrixd::I2j1Type& Matrixd::
    i2j1 ()
    {
      return this->i2j1_.get ();
    }

    void Matrixd::
    i2j1 (const I2j1Type& x)
    {
      this->i2j1_.set (x);
    }

    Matrixd::I2j1Type Matrixd::
    i2j1_default_value ()
    {
      return I2j1Type (.0);
    }

    const Matrixd::I2j2Type& Matrixd::
    i2j2 () const
    {
      return this->i2j2_.get ();
    }

    Matrixd::I2j2Type& Matrixd::
    i2j2 ()
    {
      return this->i2j2_.get ();
    }

    void Matrixd::
    i2j2 (const I2j2Type& x)
    {
      this->i2j2_.set (x);
    }

    Matrixd::I2j2Type Matrixd::
    i2j2_default_value ()
    {
      return I2j2Type (1.0);
    }

    const Matrixd::I2j3Type& Matrixd::
    i2j3 () const
    {
      return this->i2j3_.get ();
    }

    Matrixd::I2j3Type& Matrixd::
    i2j3 ()
    {
      return this->i2j3_.get ();
    }

    void Matrixd::
    i2j3 (const I2j3Type& x)
    {
      this->i2j3_.set (x);
    }

    Matrixd::I2j3Type Matrixd::
    i2j3_default_value ()
    {
      return I2j3Type (.0);
    }

    const Matrixd::I3j0Type& Matrixd::
    i3j0 () const
    {
      return this->i3j0_.get ();
    }

    Matrixd::I3j0Type& Matrixd::
    i3j0 ()
    {
      return this->i3j0_.get ();
    }

    void Matrixd::
    i3j0 (const I3j0Type& x)
    {
      this->i3j0_.set (x);
    }

    Matrixd::I3j0Type Matrixd::
    i3j0_default_value ()
    {
      return I3j0Type (.0);
    }

    const Matrixd::I3j1Type& Matrixd::
    i3j1 () const
    {
      return this->i3j1_.get ();
    }

    Matrixd::I3j1Type& Matrixd::
    i3j1 ()
    {
      return this->i3j1_.get ();
    }

    void Matrixd::
    i3j1 (const I3j1Type& x)
    {
      this->i3j1_.set (x);
    }

    Matrixd::I3j1Type Matrixd::
    i3j1_default_value ()
    {
      return I3j1Type (.0);
    }

    const Matrixd::I3j2Type& Matrixd::
    i3j2 () const
    {
      return this->i3j2_.get ();
    }

    Matrixd::I3j2Type& Matrixd::
    i3j2 ()
    {
      return this->i3j2_.get ();
    }

    void Matrixd::
    i3j2 (const I3j2Type& x)
    {
      this->i3j2_.set (x);
    }

    Matrixd::I3j2Type Matrixd::
    i3j2_default_value ()
    {
      return I3j2Type (.0);
    }

    const Matrixd::I3j3Type& Matrixd::
    i3j3 () const
    {
      return this->i3j3_.get ();
    }

    Matrixd::I3j3Type& Matrixd::
    i3j3 ()
    {
      return this->i3j3_.get ();
    }

    void Matrixd::
    i3j3 (const I3j3Type& x)
    {
      this->i3j3_.set (x);
    }

    Matrixd::I3j3Type Matrixd::
    i3j3_default_value ()
    {
      return I3j3Type (1.0);
    }


    // ParameterValue
    // 

    const ParameterValue::ADoubleOptional& ParameterValue::
    aDouble () const
    {
      return this->aDouble_;
    }

    ParameterValue::ADoubleOptional& ParameterValue::
    aDouble ()
    {
      return this->aDouble_;
    }

    void ParameterValue::
    aDouble (const ADoubleType& x)
    {
      this->aDouble_.set (x);
    }

    void ParameterValue::
    aDouble (const ADoubleOptional& x)
    {
      this->aDouble_ = x;
    }

    ParameterValue::ADoubleType ParameterValue::
    aDouble_default_value ()
    {
      return ADoubleType (::std::numeric_limits< ::xml_schema::Double >::quiet_NaN ());
    }

    const ParameterValue::AnIntegerOptional& ParameterValue::
    anInteger () const
    {
      return this->anInteger_;
    }

    ParameterValue::AnIntegerOptional& ParameterValue::
    anInteger ()
    {
      return this->anInteger_;
    }

    void ParameterValue::
    anInteger (const AnIntegerType& x)
    {
      this->anInteger_.set (x);
    }

    void ParameterValue::
    anInteger (const AnIntegerOptional& x)
    {
      this->anInteger_ = x;
    }

    ParameterValue::AnIntegerType ParameterValue::
    anInteger_default_value ()
    {
      return AnIntegerType (0);
    }

    const ParameterValue::ABoolOptional& ParameterValue::
    aBool () const
    {
      return this->aBool_;
    }

    ParameterValue::ABoolOptional& ParameterValue::
    aBool ()
    {
      return this->aBool_;
    }

    void ParameterValue::
    aBool (const ABoolType& x)
    {
      this->aBool_.set (x);
    }

    void ParameterValue::
    aBool (const ABoolOptional& x)
    {
      this->aBool_ = x;
    }

    ParameterValue::ABoolType ParameterValue::
    aBool_default_value ()
    {
      return ABoolType (false);
    }

    const ParameterValue::AStringOptional& ParameterValue::
    aString () const
    {
      return this->aString_;
    }

    ParameterValue::AStringOptional& ParameterValue::
    aString ()
    {
      return this->aString_;
    }

    void ParameterValue::
    aString (const AStringType& x)
    {
      this->aString_.set (x);
    }

    void ParameterValue::
    aString (const AStringOptional& x)
    {
      this->aString_ = x;
    }

    void ParameterValue::
    aString (::std::unique_ptr< AStringType > x)
    {
      this->aString_.set (std::move (x));
    }

    const ParameterValue::APathOptional& ParameterValue::
    aPath () const
    {
      return this->aPath_;
    }

    ParameterValue::APathOptional& ParameterValue::
    aPath ()
    {
      return this->aPath_;
    }

    void ParameterValue::
    aPath (const APathType& x)
    {
      this->aPath_.set (x);
    }

    void ParameterValue::
    aPath (const APathOptional& x)
    {
      this->aPath_ = x;
    }

    void ParameterValue::
    aPath (::std::unique_ptr< APathType > x)
    {
      this->aPath_.set (std::move (x));
    }

    const ParameterValue::AVec3dOptional& ParameterValue::
    aVec3d () const
    {
      return this->aVec3d_;
    }

    ParameterValue::AVec3dOptional& ParameterValue::
    aVec3d ()
    {
      return this->aVec3d_;
    }

    void ParameterValue::
    aVec3d (const AVec3dType& x)
    {
      this->aVec3d_.set (x);
    }

    void ParameterValue::
    aVec3d (const AVec3dOptional& x)
    {
      this->aVec3d_ = x;
    }

    void ParameterValue::
    aVec3d (::std::unique_ptr< AVec3dType > x)
    {
      this->aVec3d_.set (std::move (x));
    }

    const ParameterValue::AQuatOptional& ParameterValue::
    aQuat () const
    {
      return this->aQuat_;
    }

    ParameterValue::AQuatOptional& ParameterValue::
    aQuat ()
    {
      return this->aQuat_;
    }

    void ParameterValue::
    aQuat (const AQuatType& x)
    {
      this->aQuat_.set (x);
    }

    void ParameterValue::
    aQuat (const AQuatOptional& x)
    {
      this->aQuat_ = x;
    }

    void ParameterValue::
    aQuat (::std::unique_ptr< AQuatType > x)
    {
      this->aQuat_.set (std::move (x));
    }

    const ParameterValue::AMatrixdOptional& ParameterValue::
    aMatrixd () const
    {
      return this->aMatrixd_;
    }

    ParameterValue::AMatrixdOptional& ParameterValue::
    aMatrixd ()
    {
      return this->aMatrixd_;
    }

    void ParameterValue::
    aMatrixd (const AMatrixdType& x)
    {
      this->aMatrixd_.set (x);
    }

    void ParameterValue::
    aMatrixd (const AMatrixdOptional& x)
    {
      this->aMatrixd_ = x;
    }

    void ParameterValue::
    aMatrixd (::std::unique_ptr< AMatrixdType > x)
    {
      this->aMatrixd_.set (std::move (x));
    }


    // Parameter
    // 

    const Parameter::NameType& Parameter::
    name () const
    {
      return this->name_.get ();
    }

    Parameter::NameType& Parameter::
    name ()
    {
      return this->name_.get ();
    }

    void Parameter::
    name (const NameType& x)
    {
      this->name_.set (x);
    }

    void Parameter::
    name (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const Parameter::NameType& Parameter::
    name_default_value ()
    {
      return name_default_value_;
    }

    const Parameter::ConstantType& Parameter::
    constant () const
    {
      return this->constant_.get ();
    }

    Parameter::ConstantType& Parameter::
    constant ()
    {
      return this->constant_.get ();
    }

    void Parameter::
    constant (const ConstantType& x)
    {
      this->constant_.set (x);
    }

    Parameter::ConstantType Parameter::
    constant_default_value ()
    {
      return ConstantType (true);
    }

    const Parameter::ValueOptional& Parameter::
    value () const
    {
      return this->value_;
    }

    Parameter::ValueOptional& Parameter::
    value ()
    {
      return this->value_;
    }

    void Parameter::
    value (const ValueType& x)
    {
      this->value_.set (x);
    }

    void Parameter::
    value (const ValueOptional& x)
    {
      this->value_ = x;
    }

    Parameter::ValueType Parameter::
    value_default_value ()
    {
      return ValueType (::std::numeric_limits< ::xml_schema::Double >::quiet_NaN ());
    }

    const Parameter::IdType& Parameter::
    id () const
    {
      return this->id_.get ();
    }

    Parameter::IdType& Parameter::
    id ()
    {
      return this->id_.get ();
    }

    void Parameter::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void Parameter::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const Parameter::IdType& Parameter::
    id_default_value ()
    {
      return id_default_value_;
    }

    const Parameter::PValueOptional& Parameter::
    pValue () const
    {
      return this->pValue_;
    }

    Parameter::PValueOptional& Parameter::
    pValue ()
    {
      return this->pValue_;
    }

    void Parameter::
    pValue (const PValueType& x)
    {
      this->pValue_.set (x);
    }

    void Parameter::
    pValue (const PValueOptional& x)
    {
      this->pValue_ = x;
    }

    void Parameter::
    pValue (::std::unique_ptr< PValueType > x)
    {
      this->pValue_.set (std::move (x));
    }


    // EvolveRecord
    // 

    const EvolveRecord::IdInType& EvolveRecord::
    idIn () const
    {
      return this->idIn_.get ();
    }

    EvolveRecord::IdInType& EvolveRecord::
    idIn ()
    {
      return this->idIn_.get ();
    }

    void EvolveRecord::
    idIn (const IdInType& x)
    {
      this->idIn_.set (x);
    }

    void EvolveRecord::
    idIn (::std::unique_ptr< IdInType > x)
    {
      this->idIn_.set (std::move (x));
    }

    const EvolveRecord::IdInType& EvolveRecord::
    idIn_default_value ()
    {
      return idIn_default_value_;
    }

    const EvolveRecord::IdOutType& EvolveRecord::
    idOut () const
    {
      return this->idOut_.get ();
    }

    EvolveRecord::IdOutType& EvolveRecord::
    idOut ()
    {
      return this->idOut_.get ();
    }

    void EvolveRecord::
    idOut (const IdOutType& x)
    {
      this->idOut_.set (x);
    }

    void EvolveRecord::
    idOut (::std::unique_ptr< IdOutType > x)
    {
      this->idOut_.set (std::move (x));
    }

    const EvolveRecord::IdOutType& EvolveRecord::
    idOut_default_value ()
    {
      return idOut_default_value_;
    }


    // EvolveContainer
    // 

    const EvolveContainer::EvolveRecordSequence& EvolveContainer::
    evolveRecord () const
    {
      return this->evolveRecord_;
    }

    EvolveContainer::EvolveRecordSequence& EvolveContainer::
    evolveRecord ()
    {
      return this->evolveRecord_;
    }

    void EvolveContainer::
    evolveRecord (const EvolveRecordSequence& s)
    {
      this->evolveRecord_ = s;
    }


    // ShapeIdRecord
    // 

    const ShapeIdRecord::IdType& ShapeIdRecord::
    id () const
    {
      return this->id_.get ();
    }

    ShapeIdRecord::IdType& ShapeIdRecord::
    id ()
    {
      return this->id_.get ();
    }

    void ShapeIdRecord::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void ShapeIdRecord::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const ShapeIdRecord::IdType& ShapeIdRecord::
    id_default_value ()
    {
      return id_default_value_;
    }

    const ShapeIdRecord::ShapeOffsetType& ShapeIdRecord::
    shapeOffset () const
    {
      return this->shapeOffset_.get ();
    }

    ShapeIdRecord::ShapeOffsetType& ShapeIdRecord::
    shapeOffset ()
    {
      return this->shapeOffset_.get ();
    }

    void ShapeIdRecord::
    shapeOffset (const ShapeOffsetType& x)
    {
      this->shapeOffset_.set (x);
    }

    ShapeIdRecord::ShapeOffsetType ShapeIdRecord::
    shapeOffset_default_value ()
    {
      return ShapeOffsetType (18446744073709551615ULL);
    }


    // ShapeIdContainer
    // 

    const ShapeIdContainer::ShapeIdRecordSequence& ShapeIdContainer::
    shapeIdRecord () const
    {
      return this->shapeIdRecord_;
    }

    ShapeIdContainer::ShapeIdRecordSequence& ShapeIdContainer::
    shapeIdRecord ()
    {
      return this->shapeIdRecord_;
    }

    void ShapeIdContainer::
    shapeIdRecord (const ShapeIdRecordSequence& s)
    {
      this->shapeIdRecord_ = s;
    }


    // FeatureTagRecord
    // 

    const FeatureTagRecord::IdType& FeatureTagRecord::
    id () const
    {
      return this->id_.get ();
    }

    FeatureTagRecord::IdType& FeatureTagRecord::
    id ()
    {
      return this->id_.get ();
    }

    void FeatureTagRecord::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void FeatureTagRecord::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const FeatureTagRecord::IdType& FeatureTagRecord::
    id_default_value ()
    {
      return id_default_value_;
    }

    const FeatureTagRecord::TagType& FeatureTagRecord::
    tag () const
    {
      return this->tag_.get ();
    }

    FeatureTagRecord::TagType& FeatureTagRecord::
    tag ()
    {
      return this->tag_.get ();
    }

    void FeatureTagRecord::
    tag (const TagType& x)
    {
      this->tag_.set (x);
    }

    void FeatureTagRecord::
    tag (::std::unique_ptr< TagType > x)
    {
      this->tag_.set (std::move (x));
    }

    const FeatureTagRecord::TagType& FeatureTagRecord::
    tag_default_value ()
    {
      return tag_default_value_;
    }


    // FeatureTagContainer
    // 

    const FeatureTagContainer::FeatureTagRecordSequence& FeatureTagContainer::
    featureTagRecord () const
    {
      return this->featureTagRecord_;
    }

    FeatureTagContainer::FeatureTagRecordSequence& FeatureTagContainer::
    featureTagRecord ()
    {
      return this->featureTagRecord_;
    }

    void FeatureTagContainer::
    featureTagRecord (const FeatureTagRecordSequence& s)
    {
      this->featureTagRecord_ = s;
    }


    // IdSet
    // 

    const IdSet::IdSequence& IdSet::
    id () const
    {
      return this->id_;
    }

    IdSet::IdSequence& IdSet::
    id ()
    {
      return this->id_;
    }

    void IdSet::
    id (const IdSequence& s)
    {
      this->id_ = s;
    }

    const IdSet::IdType& IdSet::
    id_default_value ()
    {
      return id_default_value_;
    }


    // DerivedRecord
    // 

    const DerivedRecord::IdSetType& DerivedRecord::
    idSet () const
    {
      return this->idSet_.get ();
    }

    DerivedRecord::IdSetType& DerivedRecord::
    idSet ()
    {
      return this->idSet_.get ();
    }

    void DerivedRecord::
    idSet (const IdSetType& x)
    {
      this->idSet_.set (x);
    }

    void DerivedRecord::
    idSet (::std::unique_ptr< IdSetType > x)
    {
      this->idSet_.set (std::move (x));
    }

    const DerivedRecord::IdType& DerivedRecord::
    id () const
    {
      return this->id_.get ();
    }

    DerivedRecord::IdType& DerivedRecord::
    id ()
    {
      return this->id_.get ();
    }

    void DerivedRecord::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void DerivedRecord::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const DerivedRecord::IdType& DerivedRecord::
    id_default_value ()
    {
      return id_default_value_;
    }


    // DerivedContainer
    // 

    const DerivedContainer::DerivedRecordSequence& DerivedContainer::
    derivedRecord () const
    {
      return this->derivedRecord_;
    }

    DerivedContainer::DerivedRecordSequence& DerivedContainer::
    derivedRecord ()
    {
      return this->derivedRecord_;
    }

    void DerivedContainer::
    derivedRecord (const DerivedRecordSequence& s)
    {
      this->derivedRecord_ = s;
    }


    // SeerShape
    // 

    const SeerShape::RootShapeIdType& SeerShape::
    rootShapeId () const
    {
      return this->rootShapeId_.get ();
    }

    SeerShape::RootShapeIdType& SeerShape::
    rootShapeId ()
    {
      return this->rootShapeId_.get ();
    }

    void SeerShape::
    rootShapeId (const RootShapeIdType& x)
    {
      this->rootShapeId_.set (x);
    }

    void SeerShape::
    rootShapeId (::std::unique_ptr< RootShapeIdType > x)
    {
      this->rootShapeId_.set (std::move (x));
    }

    const SeerShape::RootShapeIdType& SeerShape::
    rootShapeId_default_value ()
    {
      return rootShapeId_default_value_;
    }

    const SeerShape::ShapeIdContainerType& SeerShape::
    shapeIdContainer () const
    {
      return this->shapeIdContainer_.get ();
    }

    SeerShape::ShapeIdContainerType& SeerShape::
    shapeIdContainer ()
    {
      return this->shapeIdContainer_.get ();
    }

    void SeerShape::
    shapeIdContainer (const ShapeIdContainerType& x)
    {
      this->shapeIdContainer_.set (x);
    }

    void SeerShape::
    shapeIdContainer (::std::unique_ptr< ShapeIdContainerType > x)
    {
      this->shapeIdContainer_.set (std::move (x));
    }

    const SeerShape::EvolveContainerType& SeerShape::
    evolveContainer () const
    {
      return this->evolveContainer_.get ();
    }

    SeerShape::EvolveContainerType& SeerShape::
    evolveContainer ()
    {
      return this->evolveContainer_.get ();
    }

    void SeerShape::
    evolveContainer (const EvolveContainerType& x)
    {
      this->evolveContainer_.set (x);
    }

    void SeerShape::
    evolveContainer (::std::unique_ptr< EvolveContainerType > x)
    {
      this->evolveContainer_.set (std::move (x));
    }

    const SeerShape::FeatureTagContainerType& SeerShape::
    featureTagContainer () const
    {
      return this->featureTagContainer_.get ();
    }

    SeerShape::FeatureTagContainerType& SeerShape::
    featureTagContainer ()
    {
      return this->featureTagContainer_.get ();
    }

    void SeerShape::
    featureTagContainer (const FeatureTagContainerType& x)
    {
      this->featureTagContainer_.set (x);
    }

    void SeerShape::
    featureTagContainer (::std::unique_ptr< FeatureTagContainerType > x)
    {
      this->featureTagContainer_.set (std::move (x));
    }

    const SeerShape::DerivedContainerType& SeerShape::
    derivedContainer () const
    {
      return this->derivedContainer_.get ();
    }

    SeerShape::DerivedContainerType& SeerShape::
    derivedContainer ()
    {
      return this->derivedContainer_.get ();
    }

    void SeerShape::
    derivedContainer (const DerivedContainerType& x)
    {
      this->derivedContainer_.set (x);
    }

    void SeerShape::
    derivedContainer (::std::unique_ptr< DerivedContainerType > x)
    {
      this->derivedContainer_.set (std::move (x));
    }


    // EdgeNode
    // 

    const EdgeNode::EdgeIdType& EdgeNode::
    edgeId () const
    {
      return this->edgeId_.get ();
    }

    EdgeNode::EdgeIdType& EdgeNode::
    edgeId ()
    {
      return this->edgeId_.get ();
    }

    void EdgeNode::
    edgeId (const EdgeIdType& x)
    {
      this->edgeId_.set (x);
    }

    void EdgeNode::
    edgeId (::std::unique_ptr< EdgeIdType > x)
    {
      this->edgeId_.set (std::move (x));
    }

    const EdgeNode::EdgeIdType& EdgeNode::
    edgeId_default_value ()
    {
      return edgeId_default_value_;
    }

    const EdgeNode::CenterType& EdgeNode::
    center () const
    {
      return this->center_.get ();
    }

    EdgeNode::CenterType& EdgeNode::
    center ()
    {
      return this->center_.get ();
    }

    void EdgeNode::
    center (const CenterType& x)
    {
      this->center_.set (x);
    }

    const EdgeNode::AliveType& EdgeNode::
    alive () const
    {
      return this->alive_.get ();
    }

    EdgeNode::AliveType& EdgeNode::
    alive ()
    {
      return this->alive_.get ();
    }

    void EdgeNode::
    alive (const AliveType& x)
    {
      this->alive_.set (x);
    }


    // EdgeNodes
    // 

    const EdgeNodes::ArraySequence& EdgeNodes::
    array () const
    {
      return this->array_;
    }

    EdgeNodes::ArraySequence& EdgeNodes::
    array ()
    {
      return this->array_;
    }

    void EdgeNodes::
    array (const ArraySequence& s)
    {
      this->array_ = s;
    }


    // EdgeSplit
    // 

    const EdgeSplit::EdgeHistoryType& EdgeSplit::
    edgeHistory () const
    {
      return this->edgeHistory_.get ();
    }

    EdgeSplit::EdgeHistoryType& EdgeSplit::
    edgeHistory ()
    {
      return this->edgeHistory_.get ();
    }

    void EdgeSplit::
    edgeHistory (const EdgeHistoryType& x)
    {
      this->edgeHistory_.set (x);
    }

    void EdgeSplit::
    edgeHistory (::std::unique_ptr< EdgeHistoryType > x)
    {
      this->edgeHistory_.set (std::move (x));
    }

    const EdgeSplit::NodesType& EdgeSplit::
    nodes () const
    {
      return this->nodes_.get ();
    }

    EdgeSplit::NodesType& EdgeSplit::
    nodes ()
    {
      return this->nodes_.get ();
    }

    void EdgeSplit::
    nodes (const NodesType& x)
    {
      this->nodes_.set (x);
    }

    void EdgeSplit::
    nodes (::std::unique_ptr< NodesType > x)
    {
      this->nodes_.set (std::move (x));
    }


    // EdgeSplits
    // 

    const EdgeSplits::ArraySequence& EdgeSplits::
    array () const
    {
      return this->array_;
    }

    EdgeSplits::ArraySequence& EdgeSplits::
    array ()
    {
      return this->array_;
    }

    void EdgeSplits::
    array (const ArraySequence& s)
    {
      this->array_ = s;
    }


    // IntersectionNode
    // 

    const IntersectionNode::EdgeIdType& IntersectionNode::
    edgeId () const
    {
      return this->edgeId_.get ();
    }

    IntersectionNode::EdgeIdType& IntersectionNode::
    edgeId ()
    {
      return this->edgeId_.get ();
    }

    void IntersectionNode::
    edgeId (const EdgeIdType& x)
    {
      this->edgeId_.set (x);
    }

    void IntersectionNode::
    edgeId (::std::unique_ptr< EdgeIdType > x)
    {
      this->edgeId_.set (std::move (x));
    }

    const IntersectionNode::EdgeIdType& IntersectionNode::
    edgeId_default_value ()
    {
      return edgeId_default_value_;
    }

    const IntersectionNode::CenterXType& IntersectionNode::
    centerX () const
    {
      return this->centerX_.get ();
    }

    IntersectionNode::CenterXType& IntersectionNode::
    centerX ()
    {
      return this->centerX_.get ();
    }

    void IntersectionNode::
    centerX (const CenterXType& x)
    {
      this->centerX_.set (x);
    }

    const IntersectionNode::CenterYType& IntersectionNode::
    centerY () const
    {
      return this->centerY_.get ();
    }

    IntersectionNode::CenterYType& IntersectionNode::
    centerY ()
    {
      return this->centerY_.get ();
    }

    void IntersectionNode::
    centerY (const CenterYType& x)
    {
      this->centerY_.set (x);
    }

    const IntersectionNode::AliveType& IntersectionNode::
    alive () const
    {
      return this->alive_.get ();
    }

    IntersectionNode::AliveType& IntersectionNode::
    alive ()
    {
      return this->alive_.get ();
    }

    void IntersectionNode::
    alive (const AliveType& x)
    {
      this->alive_.set (x);
    }


    // IntersectionNodes
    // 

    const IntersectionNodes::ArraySequence& IntersectionNodes::
    array () const
    {
      return this->array_;
    }

    IntersectionNodes::ArraySequence& IntersectionNodes::
    array ()
    {
      return this->array_;
    }

    void IntersectionNodes::
    array (const ArraySequence& s)
    {
      this->array_ = s;
    }


    // EdgeIntersection
    // 

    const EdgeIntersection::FaceHistory1Type& EdgeIntersection::
    faceHistory1 () const
    {
      return this->faceHistory1_.get ();
    }

    EdgeIntersection::FaceHistory1Type& EdgeIntersection::
    faceHistory1 ()
    {
      return this->faceHistory1_.get ();
    }

    void EdgeIntersection::
    faceHistory1 (const FaceHistory1Type& x)
    {
      this->faceHistory1_.set (x);
    }

    void EdgeIntersection::
    faceHistory1 (::std::unique_ptr< FaceHistory1Type > x)
    {
      this->faceHistory1_.set (std::move (x));
    }

    const EdgeIntersection::FaceHistory2Type& EdgeIntersection::
    faceHistory2 () const
    {
      return this->faceHistory2_.get ();
    }

    EdgeIntersection::FaceHistory2Type& EdgeIntersection::
    faceHistory2 ()
    {
      return this->faceHistory2_.get ();
    }

    void EdgeIntersection::
    faceHistory2 (const FaceHistory2Type& x)
    {
      this->faceHistory2_.set (x);
    }

    void EdgeIntersection::
    faceHistory2 (::std::unique_ptr< FaceHistory2Type > x)
    {
      this->faceHistory2_.set (std::move (x));
    }

    const EdgeIntersection::NodesType& EdgeIntersection::
    nodes () const
    {
      return this->nodes_.get ();
    }

    EdgeIntersection::NodesType& EdgeIntersection::
    nodes ()
    {
      return this->nodes_.get ();
    }

    void EdgeIntersection::
    nodes (const NodesType& x)
    {
      this->nodes_.set (x);
    }

    void EdgeIntersection::
    nodes (::std::unique_ptr< NodesType > x)
    {
      this->nodes_.set (std::move (x));
    }


    // EdgeIntersections
    // 

    const EdgeIntersections::ArraySequence& EdgeIntersections::
    array () const
    {
      return this->array_;
    }

    EdgeIntersections::ArraySequence& EdgeIntersections::
    array ()
    {
      return this->array_;
    }

    void EdgeIntersections::
    array (const ArraySequence& s)
    {
      this->array_ = s;
    }


    // FaceNode
    // 

    const FaceNode::FaceIdType& FaceNode::
    faceId () const
    {
      return this->faceId_.get ();
    }

    FaceNode::FaceIdType& FaceNode::
    faceId ()
    {
      return this->faceId_.get ();
    }

    void FaceNode::
    faceId (const FaceIdType& x)
    {
      this->faceId_.set (x);
    }

    void FaceNode::
    faceId (::std::unique_ptr< FaceIdType > x)
    {
      this->faceId_.set (std::move (x));
    }

    const FaceNode::FaceIdType& FaceNode::
    faceId_default_value ()
    {
      return faceId_default_value_;
    }

    const FaceNode::WireIdType& FaceNode::
    wireId () const
    {
      return this->wireId_.get ();
    }

    FaceNode::WireIdType& FaceNode::
    wireId ()
    {
      return this->wireId_.get ();
    }

    void FaceNode::
    wireId (const WireIdType& x)
    {
      this->wireId_.set (x);
    }

    void FaceNode::
    wireId (::std::unique_ptr< WireIdType > x)
    {
      this->wireId_.set (std::move (x));
    }

    const FaceNode::WireIdType& FaceNode::
    wireId_default_value ()
    {
      return wireId_default_value_;
    }

    const FaceNode::CenterXType& FaceNode::
    centerX () const
    {
      return this->centerX_.get ();
    }

    FaceNode::CenterXType& FaceNode::
    centerX ()
    {
      return this->centerX_.get ();
    }

    void FaceNode::
    centerX (const CenterXType& x)
    {
      this->centerX_.set (x);
    }

    const FaceNode::CenterYType& FaceNode::
    centerY () const
    {
      return this->centerY_.get ();
    }

    FaceNode::CenterYType& FaceNode::
    centerY ()
    {
      return this->centerY_.get ();
    }

    void FaceNode::
    centerY (const CenterYType& x)
    {
      this->centerY_.set (x);
    }

    const FaceNode::AliveType& FaceNode::
    alive () const
    {
      return this->alive_.get ();
    }

    FaceNode::AliveType& FaceNode::
    alive ()
    {
      return this->alive_.get ();
    }

    void FaceNode::
    alive (const AliveType& x)
    {
      this->alive_.set (x);
    }


    // FaceNodes
    // 

    const FaceNodes::ArraySequence& FaceNodes::
    array () const
    {
      return this->array_;
    }

    FaceNodes::ArraySequence& FaceNodes::
    array ()
    {
      return this->array_;
    }

    void FaceNodes::
    array (const ArraySequence& s)
    {
      this->array_ = s;
    }


    // FaceSplit
    // 

    const FaceSplit::FaceHistoryType& FaceSplit::
    faceHistory () const
    {
      return this->faceHistory_.get ();
    }

    FaceSplit::FaceHistoryType& FaceSplit::
    faceHistory ()
    {
      return this->faceHistory_.get ();
    }

    void FaceSplit::
    faceHistory (const FaceHistoryType& x)
    {
      this->faceHistory_.set (x);
    }

    void FaceSplit::
    faceHistory (::std::unique_ptr< FaceHistoryType > x)
    {
      this->faceHistory_.set (std::move (x));
    }

    const FaceSplit::NodesType& FaceSplit::
    nodes () const
    {
      return this->nodes_.get ();
    }

    FaceSplit::NodesType& FaceSplit::
    nodes ()
    {
      return this->nodes_.get ();
    }

    void FaceSplit::
    nodes (const NodesType& x)
    {
      this->nodes_.set (x);
    }

    void FaceSplit::
    nodes (::std::unique_ptr< NodesType > x)
    {
      this->nodes_.set (std::move (x));
    }


    // FaceSplits
    // 

    const FaceSplits::ArraySequence& FaceSplits::
    array () const
    {
      return this->array_;
    }

    FaceSplits::ArraySequence& FaceSplits::
    array ()
    {
      return this->array_;
    }

    void FaceSplits::
    array (const ArraySequence& s)
    {
      this->array_ = s;
    }


    // SameDomain
    // 

    const SameDomain::IdType& SameDomain::
    id () const
    {
      return this->id_.get ();
    }

    SameDomain::IdType& SameDomain::
    id ()
    {
      return this->id_.get ();
    }

    void SameDomain::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void SameDomain::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const SameDomain::IdType& SameDomain::
    id_default_value ()
    {
      return id_default_value_;
    }

    const SameDomain::HistoriesType& SameDomain::
    histories () const
    {
      return this->histories_.get ();
    }

    SameDomain::HistoriesType& SameDomain::
    histories ()
    {
      return this->histories_.get ();
    }

    void SameDomain::
    histories (const HistoriesType& x)
    {
      this->histories_.set (x);
    }

    void SameDomain::
    histories (::std::unique_ptr< HistoriesType > x)
    {
      this->histories_.set (std::move (x));
    }


    // SameDomains
    // 

    const SameDomains::ArraySequence& SameDomains::
    array () const
    {
      return this->array_;
    }

    SameDomains::ArraySequence& SameDomains::
    array ()
    {
      return this->array_;
    }

    void SameDomains::
    array (const ArraySequence& s)
    {
      this->array_ = s;
    }


    // IntersectionMapper
    // 

    const IntersectionMapper::EdgeIntersectionsType& IntersectionMapper::
    edgeIntersections () const
    {
      return this->edgeIntersections_.get ();
    }

    IntersectionMapper::EdgeIntersectionsType& IntersectionMapper::
    edgeIntersections ()
    {
      return this->edgeIntersections_.get ();
    }

    void IntersectionMapper::
    edgeIntersections (const EdgeIntersectionsType& x)
    {
      this->edgeIntersections_.set (x);
    }

    void IntersectionMapper::
    edgeIntersections (::std::unique_ptr< EdgeIntersectionsType > x)
    {
      this->edgeIntersections_.set (std::move (x));
    }

    const IntersectionMapper::FaceSplitsType& IntersectionMapper::
    faceSplits () const
    {
      return this->faceSplits_.get ();
    }

    IntersectionMapper::FaceSplitsType& IntersectionMapper::
    faceSplits ()
    {
      return this->faceSplits_.get ();
    }

    void IntersectionMapper::
    faceSplits (const FaceSplitsType& x)
    {
      this->faceSplits_.set (x);
    }

    void IntersectionMapper::
    faceSplits (::std::unique_ptr< FaceSplitsType > x)
    {
      this->faceSplits_.set (std::move (x));
    }

    const IntersectionMapper::EdgeSplitsType& IntersectionMapper::
    edgeSplits () const
    {
      return this->edgeSplits_.get ();
    }

    IntersectionMapper::EdgeSplitsType& IntersectionMapper::
    edgeSplits ()
    {
      return this->edgeSplits_.get ();
    }

    void IntersectionMapper::
    edgeSplits (const EdgeSplitsType& x)
    {
      this->edgeSplits_.set (x);
    }

    void IntersectionMapper::
    edgeSplits (::std::unique_ptr< EdgeSplitsType > x)
    {
      this->edgeSplits_.set (std::move (x));
    }

    const IntersectionMapper::SameDomainsType& IntersectionMapper::
    sameDomains () const
    {
      return this->sameDomains_.get ();
    }

    IntersectionMapper::SameDomainsType& IntersectionMapper::
    sameDomains ()
    {
      return this->sameDomains_.get ();
    }

    void IntersectionMapper::
    sameDomains (const SameDomainsType& x)
    {
      this->sameDomains_.set (x);
    }

    void IntersectionMapper::
    sameDomains (::std::unique_ptr< SameDomainsType > x)
    {
      this->sameDomains_.set (std::move (x));
    }


    // ColorValue
    // 


    // Color
    // 

    const Color::RType& Color::
    r () const
    {
      return this->r_.get ();
    }

    Color::RType& Color::
    r ()
    {
      return this->r_.get ();
    }

    void Color::
    r (const RType& x)
    {
      this->r_.set (x);
    }

    void Color::
    r (::std::unique_ptr< RType > x)
    {
      this->r_.set (std::move (x));
    }

    const Color::GType& Color::
    g () const
    {
      return this->g_.get ();
    }

    Color::GType& Color::
    g ()
    {
      return this->g_.get ();
    }

    void Color::
    g (const GType& x)
    {
      this->g_.set (x);
    }

    void Color::
    g (::std::unique_ptr< GType > x)
    {
      this->g_.set (std::move (x));
    }

    const Color::BType& Color::
    b () const
    {
      return this->b_.get ();
    }

    Color::BType& Color::
    b ()
    {
      return this->b_.get ();
    }

    void Color::
    b (const BType& x)
    {
      this->b_.set (x);
    }

    void Color::
    b (::std::unique_ptr< BType > x)
    {
      this->b_.set (std::move (x));
    }

    const Color::AType& Color::
    a () const
    {
      return this->a_.get ();
    }

    Color::AType& Color::
    a ()
    {
      return this->a_.get ();
    }

    void Color::
    a (const AType& x)
    {
      this->a_.set (x);
    }

    void Color::
    a (::std::unique_ptr< AType > x)
    {
      this->a_.set (std::move (x));
    }


    // FeatureBase
    // 

    const FeatureBase::NameType& FeatureBase::
    name () const
    {
      return this->name_.get ();
    }

    FeatureBase::NameType& FeatureBase::
    name ()
    {
      return this->name_.get ();
    }

    void FeatureBase::
    name (const NameType& x)
    {
      this->name_.set (x);
    }

    void FeatureBase::
    name (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const FeatureBase::NameType& FeatureBase::
    name_default_value ()
    {
      return name_default_value_;
    }

    const FeatureBase::IdType& FeatureBase::
    id () const
    {
      return this->id_.get ();
    }

    FeatureBase::IdType& FeatureBase::
    id ()
    {
      return this->id_.get ();
    }

    void FeatureBase::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void FeatureBase::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const FeatureBase::IdType& FeatureBase::
    id_default_value ()
    {
      return id_default_value_;
    }

    const FeatureBase::SeerShapeOptional& FeatureBase::
    seerShape () const
    {
      return this->seerShape_;
    }

    FeatureBase::SeerShapeOptional& FeatureBase::
    seerShape ()
    {
      return this->seerShape_;
    }

    void FeatureBase::
    seerShape (const SeerShapeType& x)
    {
      this->seerShape_.set (x);
    }

    void FeatureBase::
    seerShape (const SeerShapeOptional& x)
    {
      this->seerShape_ = x;
    }

    void FeatureBase::
    seerShape (::std::unique_ptr< SeerShapeType > x)
    {
      this->seerShape_.set (std::move (x));
    }

    const FeatureBase::IntersectionMapperOptional& FeatureBase::
    intersectionMapper () const
    {
      return this->intersectionMapper_;
    }

    FeatureBase::IntersectionMapperOptional& FeatureBase::
    intersectionMapper ()
    {
      return this->intersectionMapper_;
    }

    void FeatureBase::
    intersectionMapper (const IntersectionMapperType& x)
    {
      this->intersectionMapper_.set (x);
    }

    void FeatureBase::
    intersectionMapper (const IntersectionMapperOptional& x)
    {
      this->intersectionMapper_ = x;
    }

    void FeatureBase::
    intersectionMapper (::std::unique_ptr< IntersectionMapperType > x)
    {
      this->intersectionMapper_.set (std::move (x));
    }

    const FeatureBase::ColorOptional& FeatureBase::
    color () const
    {
      return this->color_;
    }

    FeatureBase::ColorOptional& FeatureBase::
    color ()
    {
      return this->color_;
    }

    void FeatureBase::
    color (const ColorType& x)
    {
      this->color_.set (x);
    }

    void FeatureBase::
    color (const ColorOptional& x)
    {
      this->color_ = x;
    }

    void FeatureBase::
    color (::std::unique_ptr< ColorType > x)
    {
      this->color_.set (std::move (x));
    }

    const FeatureBase::StateOptional& FeatureBase::
    state () const
    {
      return this->state_;
    }

    FeatureBase::StateOptional& FeatureBase::
    state ()
    {
      return this->state_;
    }

    void FeatureBase::
    state (const StateType& x)
    {
      this->state_.set (x);
    }

    void FeatureBase::
    state (const StateOptional& x)
    {
      this->state_ = x;
    }

    void FeatureBase::
    state (::std::unique_ptr< StateType > x)
    {
      this->state_.set (std::move (x));
    }


    // Pick
    // 

    const Pick::IdType& Pick::
    id () const
    {
      return this->id_.get ();
    }

    Pick::IdType& Pick::
    id ()
    {
      return this->id_.get ();
    }

    void Pick::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void Pick::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const Pick::IdType& Pick::
    id_default_value ()
    {
      return id_default_value_;
    }

    const Pick::UType& Pick::
    u () const
    {
      return this->u_.get ();
    }

    Pick::UType& Pick::
    u ()
    {
      return this->u_.get ();
    }

    void Pick::
    u (const UType& x)
    {
      this->u_.set (x);
    }

    Pick::UType Pick::
    u_default_value ()
    {
      return UType (.0);
    }

    const Pick::VType& Pick::
    v () const
    {
      return this->v_.get ();
    }

    Pick::VType& Pick::
    v ()
    {
      return this->v_.get ();
    }

    void Pick::
    v (const VType& x)
    {
      this->v_.set (x);
    }

    Pick::VType Pick::
    v_default_value ()
    {
      return VType (.0);
    }

    const Pick::HistoryOptional& Pick::
    history () const
    {
      return this->history_;
    }

    Pick::HistoryOptional& Pick::
    history ()
    {
      return this->history_;
    }

    void Pick::
    history (const HistoryType& x)
    {
      this->history_.set (x);
    }

    void Pick::
    history (const HistoryOptional& x)
    {
      this->history_ = x;
    }

    void Pick::
    history (::std::unique_ptr< HistoryType > x)
    {
      this->history_.set (std::move (x));
    }


    // Picks
    // 

    const Picks::ArraySequence& Picks::
    array () const
    {
      return this->array_;
    }

    Picks::ArraySequence& Picks::
    array ()
    {
      return this->array_;
    }

    void Picks::
    array (const ArraySequence& s)
    {
      this->array_ = s;
    }


    // PLabel
    // 

    const PLabel::MatrixType& PLabel::
    matrix () const
    {
      return this->matrix_.get ();
    }

    PLabel::MatrixType& PLabel::
    matrix ()
    {
      return this->matrix_.get ();
    }

    void PLabel::
    matrix (const MatrixType& x)
    {
      this->matrix_.set (x);
    }

    void PLabel::
    matrix (::std::unique_ptr< MatrixType > x)
    {
      this->matrix_.set (std::move (x));
    }

    const PLabel::ColorType& PLabel::
    color () const
    {
      return this->color_.get ();
    }

    PLabel::ColorType& PLabel::
    color ()
    {
      return this->color_.get ();
    }

    void PLabel::
    color (const ColorType& x)
    {
      this->color_.set (x);
    }

    void PLabel::
    color (::std::unique_ptr< ColorType > x)
    {
      this->color_.set (std::move (x));
    }


    // CSysDragger
    // 

    const CSysDragger::MatrixType& CSysDragger::
    matrix () const
    {
      return this->matrix_.get ();
    }

    CSysDragger::MatrixType& CSysDragger::
    matrix ()
    {
      return this->matrix_.get ();
    }

    void CSysDragger::
    matrix (const MatrixType& x)
    {
      this->matrix_.set (x);
    }

    void CSysDragger::
    matrix (::std::unique_ptr< MatrixType > x)
    {
      this->matrix_.set (std::move (x));
    }

    const CSysDragger::LinkedType& CSysDragger::
    linked () const
    {
      return this->linked_.get ();
    }

    CSysDragger::LinkedType& CSysDragger::
    linked ()
    {
      return this->linked_.get ();
    }

    void CSysDragger::
    linked (const LinkedType& x)
    {
      this->linked_.set (x);
    }

    const CSysDragger::FeatureIdType& CSysDragger::
    featureId () const
    {
      return this->featureId_.get ();
    }

    CSysDragger::FeatureIdType& CSysDragger::
    featureId ()
    {
      return this->featureId_.get ();
    }

    void CSysDragger::
    featureId (const FeatureIdType& x)
    {
      this->featureId_.set (x);
    }

    void CSysDragger::
    featureId (::std::unique_ptr< FeatureIdType > x)
    {
      this->featureId_.set (std::move (x));
    }

    const CSysDragger::FeatureIdType& CSysDragger::
    featureId_default_value ()
    {
      return featureId_default_value_;
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace prj
{
  namespace srl
  {
    // Vec3d
    //

    Vec3d::
    Vec3d (const XType& x,
           const YType& y,
           const ZType& z)
    : ::xml_schema::Type (),
      x_ (x, this),
      y_ (y, this),
      z_ (z, this)
    {
    }

    Vec3d::
    Vec3d (const Vec3d& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      x_ (x.x_, f, this),
      y_ (x.y_, f, this),
      z_ (x.z_, f, this)
    {
    }

    Vec3d::
    Vec3d (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      x_ (this),
      y_ (this),
      z_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Vec3d::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // x
        //
        if (n.name () == "x" && n.namespace_ ().empty ())
        {
          if (!x_.present ())
          {
            this->x_.set (XTraits::create (i, f, this));
            continue;
          }
        }

        // y
        //
        if (n.name () == "y" && n.namespace_ ().empty ())
        {
          if (!y_.present ())
          {
            this->y_.set (YTraits::create (i, f, this));
            continue;
          }
        }

        // z
        //
        if (n.name () == "z" && n.namespace_ ().empty ())
        {
          if (!z_.present ())
          {
            this->z_.set (ZTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!x_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "x",
          "");
      }

      if (!y_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "y",
          "");
      }

      if (!z_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "z",
          "");
      }
    }

    Vec3d* Vec3d::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Vec3d (*this, f, c);
    }

    Vec3d& Vec3d::
    operator= (const Vec3d& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->x_ = x.x_;
        this->y_ = x.y_;
        this->z_ = x.z_;
      }

      return *this;
    }

    Vec3d::
    ~Vec3d ()
    {
    }

    // Quat
    //

    Quat::
    Quat (const XType& x,
          const YType& y,
          const ZType& z,
          const WType& w)
    : ::xml_schema::Type (),
      x_ (x, this),
      y_ (y, this),
      z_ (z, this),
      w_ (w, this)
    {
    }

    Quat::
    Quat (const Quat& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      x_ (x.x_, f, this),
      y_ (x.y_, f, this),
      z_ (x.z_, f, this),
      w_ (x.w_, f, this)
    {
    }

    Quat::
    Quat (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      x_ (this),
      y_ (this),
      z_ (this),
      w_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Quat::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // x
        //
        if (n.name () == "x" && n.namespace_ ().empty ())
        {
          if (!x_.present ())
          {
            this->x_.set (XTraits::create (i, f, this));
            continue;
          }
        }

        // y
        //
        if (n.name () == "y" && n.namespace_ ().empty ())
        {
          if (!y_.present ())
          {
            this->y_.set (YTraits::create (i, f, this));
            continue;
          }
        }

        // z
        //
        if (n.name () == "z" && n.namespace_ ().empty ())
        {
          if (!z_.present ())
          {
            this->z_.set (ZTraits::create (i, f, this));
            continue;
          }
        }

        // w
        //
        if (n.name () == "w" && n.namespace_ ().empty ())
        {
          if (!w_.present ())
          {
            this->w_.set (WTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!x_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "x",
          "");
      }

      if (!y_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "y",
          "");
      }

      if (!z_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "z",
          "");
      }

      if (!w_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "w",
          "");
      }
    }

    Quat* Quat::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Quat (*this, f, c);
    }

    Quat& Quat::
    operator= (const Quat& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->x_ = x.x_;
        this->y_ = x.y_;
        this->z_ = x.z_;
        this->w_ = x.w_;
      }

      return *this;
    }

    Quat::
    ~Quat ()
    {
    }

    // Matrixd
    //

    Matrixd::
    Matrixd (const I0j0Type& i0j0,
             const I0j1Type& i0j1,
             const I0j2Type& i0j2,
             const I0j3Type& i0j3,
             const I1j0Type& i1j0,
             const I1j1Type& i1j1,
             const I1j2Type& i1j2,
             const I1j3Type& i1j3,
             const I2j0Type& i2j0,
             const I2j1Type& i2j1,
             const I2j2Type& i2j2,
             const I2j3Type& i2j3,
             const I3j0Type& i3j0,
             const I3j1Type& i3j1,
             const I3j2Type& i3j2,
             const I3j3Type& i3j3)
    : ::xml_schema::Type (),
      i0j0_ (i0j0, this),
      i0j1_ (i0j1, this),
      i0j2_ (i0j2, this),
      i0j3_ (i0j3, this),
      i1j0_ (i1j0, this),
      i1j1_ (i1j1, this),
      i1j2_ (i1j2, this),
      i1j3_ (i1j3, this),
      i2j0_ (i2j0, this),
      i2j1_ (i2j1, this),
      i2j2_ (i2j2, this),
      i2j3_ (i2j3, this),
      i3j0_ (i3j0, this),
      i3j1_ (i3j1, this),
      i3j2_ (i3j2, this),
      i3j3_ (i3j3, this)
    {
    }

    Matrixd::
    Matrixd (const Matrixd& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      i0j0_ (x.i0j0_, f, this),
      i0j1_ (x.i0j1_, f, this),
      i0j2_ (x.i0j2_, f, this),
      i0j3_ (x.i0j3_, f, this),
      i1j0_ (x.i1j0_, f, this),
      i1j1_ (x.i1j1_, f, this),
      i1j2_ (x.i1j2_, f, this),
      i1j3_ (x.i1j3_, f, this),
      i2j0_ (x.i2j0_, f, this),
      i2j1_ (x.i2j1_, f, this),
      i2j2_ (x.i2j2_, f, this),
      i2j3_ (x.i2j3_, f, this),
      i3j0_ (x.i3j0_, f, this),
      i3j1_ (x.i3j1_, f, this),
      i3j2_ (x.i3j2_, f, this),
      i3j3_ (x.i3j3_, f, this)
    {
    }

    Matrixd::
    Matrixd (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      i0j0_ (this),
      i0j1_ (this),
      i0j2_ (this),
      i0j3_ (this),
      i1j0_ (this),
      i1j1_ (this),
      i1j2_ (this),
      i1j3_ (this),
      i2j0_ (this),
      i2j1_ (this),
      i2j2_ (this),
      i2j3_ (this),
      i3j0_ (this),
      i3j1_ (this),
      i3j2_ (this),
      i3j3_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Matrixd::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // i0j0
        //
        if (n.name () == "i0j0" && n.namespace_ ().empty ())
        {
          if (!i0j0_.present ())
          {
            this->i0j0_.set (I0j0Traits::create (i, f, this));
            continue;
          }
        }

        // i0j1
        //
        if (n.name () == "i0j1" && n.namespace_ ().empty ())
        {
          if (!i0j1_.present ())
          {
            this->i0j1_.set (I0j1Traits::create (i, f, this));
            continue;
          }
        }

        // i0j2
        //
        if (n.name () == "i0j2" && n.namespace_ ().empty ())
        {
          if (!i0j2_.present ())
          {
            this->i0j2_.set (I0j2Traits::create (i, f, this));
            continue;
          }
        }

        // i0j3
        //
        if (n.name () == "i0j3" && n.namespace_ ().empty ())
        {
          if (!i0j3_.present ())
          {
            this->i0j3_.set (I0j3Traits::create (i, f, this));
            continue;
          }
        }

        // i1j0
        //
        if (n.name () == "i1j0" && n.namespace_ ().empty ())
        {
          if (!i1j0_.present ())
          {
            this->i1j0_.set (I1j0Traits::create (i, f, this));
            continue;
          }
        }

        // i1j1
        //
        if (n.name () == "i1j1" && n.namespace_ ().empty ())
        {
          if (!i1j1_.present ())
          {
            this->i1j1_.set (I1j1Traits::create (i, f, this));
            continue;
          }
        }

        // i1j2
        //
        if (n.name () == "i1j2" && n.namespace_ ().empty ())
        {
          if (!i1j2_.present ())
          {
            this->i1j2_.set (I1j2Traits::create (i, f, this));
            continue;
          }
        }

        // i1j3
        //
        if (n.name () == "i1j3" && n.namespace_ ().empty ())
        {
          if (!i1j3_.present ())
          {
            this->i1j3_.set (I1j3Traits::create (i, f, this));
            continue;
          }
        }

        // i2j0
        //
        if (n.name () == "i2j0" && n.namespace_ ().empty ())
        {
          if (!i2j0_.present ())
          {
            this->i2j0_.set (I2j0Traits::create (i, f, this));
            continue;
          }
        }

        // i2j1
        //
        if (n.name () == "i2j1" && n.namespace_ ().empty ())
        {
          if (!i2j1_.present ())
          {
            this->i2j1_.set (I2j1Traits::create (i, f, this));
            continue;
          }
        }

        // i2j2
        //
        if (n.name () == "i2j2" && n.namespace_ ().empty ())
        {
          if (!i2j2_.present ())
          {
            this->i2j2_.set (I2j2Traits::create (i, f, this));
            continue;
          }
        }

        // i2j3
        //
        if (n.name () == "i2j3" && n.namespace_ ().empty ())
        {
          if (!i2j3_.present ())
          {
            this->i2j3_.set (I2j3Traits::create (i, f, this));
            continue;
          }
        }

        // i3j0
        //
        if (n.name () == "i3j0" && n.namespace_ ().empty ())
        {
          if (!i3j0_.present ())
          {
            this->i3j0_.set (I3j0Traits::create (i, f, this));
            continue;
          }
        }

        // i3j1
        //
        if (n.name () == "i3j1" && n.namespace_ ().empty ())
        {
          if (!i3j1_.present ())
          {
            this->i3j1_.set (I3j1Traits::create (i, f, this));
            continue;
          }
        }

        // i3j2
        //
        if (n.name () == "i3j2" && n.namespace_ ().empty ())
        {
          if (!i3j2_.present ())
          {
            this->i3j2_.set (I3j2Traits::create (i, f, this));
            continue;
          }
        }

        // i3j3
        //
        if (n.name () == "i3j3" && n.namespace_ ().empty ())
        {
          if (!i3j3_.present ())
          {
            this->i3j3_.set (I3j3Traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!i0j0_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "i0j0",
          "");
      }

      if (!i0j1_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "i0j1",
          "");
      }

      if (!i0j2_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "i0j2",
          "");
      }

      if (!i0j3_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "i0j3",
          "");
      }

      if (!i1j0_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "i1j0",
          "");
      }

      if (!i1j1_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "i1j1",
          "");
      }

      if (!i1j2_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "i1j2",
          "");
      }

      if (!i1j3_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "i1j3",
          "");
      }

      if (!i2j0_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "i2j0",
          "");
      }

      if (!i2j1_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "i2j1",
          "");
      }

      if (!i2j2_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "i2j2",
          "");
      }

      if (!i2j3_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "i2j3",
          "");
      }

      if (!i3j0_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "i3j0",
          "");
      }

      if (!i3j1_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "i3j1",
          "");
      }

      if (!i3j2_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "i3j2",
          "");
      }

      if (!i3j3_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "i3j3",
          "");
      }
    }

    Matrixd* Matrixd::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Matrixd (*this, f, c);
    }

    Matrixd& Matrixd::
    operator= (const Matrixd& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->i0j0_ = x.i0j0_;
        this->i0j1_ = x.i0j1_;
        this->i0j2_ = x.i0j2_;
        this->i0j3_ = x.i0j3_;
        this->i1j0_ = x.i1j0_;
        this->i1j1_ = x.i1j1_;
        this->i1j2_ = x.i1j2_;
        this->i1j3_ = x.i1j3_;
        this->i2j0_ = x.i2j0_;
        this->i2j1_ = x.i2j1_;
        this->i2j2_ = x.i2j2_;
        this->i2j3_ = x.i2j3_;
        this->i3j0_ = x.i3j0_;
        this->i3j1_ = x.i3j1_;
        this->i3j2_ = x.i3j2_;
        this->i3j3_ = x.i3j3_;
      }

      return *this;
    }

    Matrixd::
    ~Matrixd ()
    {
    }

    // ParameterValue
    //

    ParameterValue::
    ParameterValue ()
    : ::xml_schema::Type (),
      aDouble_ (this),
      anInteger_ (this),
      aBool_ (this),
      aString_ (this),
      aPath_ (this),
      aVec3d_ (this),
      aQuat_ (this),
      aMatrixd_ (this)
    {
    }

    ParameterValue::
    ParameterValue (const ParameterValue& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      aDouble_ (x.aDouble_, f, this),
      anInteger_ (x.anInteger_, f, this),
      aBool_ (x.aBool_, f, this),
      aString_ (x.aString_, f, this),
      aPath_ (x.aPath_, f, this),
      aVec3d_ (x.aVec3d_, f, this),
      aQuat_ (x.aQuat_, f, this),
      aMatrixd_ (x.aMatrixd_, f, this)
    {
    }

    ParameterValue::
    ParameterValue (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      aDouble_ (this),
      anInteger_ (this),
      aBool_ (this),
      aString_ (this),
      aPath_ (this),
      aVec3d_ (this),
      aQuat_ (this),
      aMatrixd_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ParameterValue::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // aDouble
        //
        if (n.name () == "aDouble" && n.namespace_ ().empty ())
        {
          if (!this->aDouble_)
          {
            this->aDouble_.set (ADoubleTraits::create (i, f, this));
            continue;
          }
        }

        // anInteger
        //
        if (n.name () == "anInteger" && n.namespace_ ().empty ())
        {
          if (!this->anInteger_)
          {
            this->anInteger_.set (AnIntegerTraits::create (i, f, this));
            continue;
          }
        }

        // aBool
        //
        if (n.name () == "aBool" && n.namespace_ ().empty ())
        {
          if (!this->aBool_)
          {
            this->aBool_.set (ABoolTraits::create (i, f, this));
            continue;
          }
        }

        // aString
        //
        if (n.name () == "aString" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< AStringType > r (
            AStringTraits::create (i, f, this));

          if (!this->aString_)
          {
            this->aString_.set (::std::move (r));
            continue;
          }
        }

        // aPath
        //
        if (n.name () == "aPath" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< APathType > r (
            APathTraits::create (i, f, this));

          if (!this->aPath_)
          {
            this->aPath_.set (::std::move (r));
            continue;
          }
        }

        // aVec3d
        //
        if (n.name () == "aVec3d" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< AVec3dType > r (
            AVec3dTraits::create (i, f, this));

          if (!this->aVec3d_)
          {
            this->aVec3d_.set (::std::move (r));
            continue;
          }
        }

        // aQuat
        //
        if (n.name () == "aQuat" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< AQuatType > r (
            AQuatTraits::create (i, f, this));

          if (!this->aQuat_)
          {
            this->aQuat_.set (::std::move (r));
            continue;
          }
        }

        // aMatrixd
        //
        if (n.name () == "aMatrixd" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< AMatrixdType > r (
            AMatrixdTraits::create (i, f, this));

          if (!this->aMatrixd_)
          {
            this->aMatrixd_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ParameterValue* ParameterValue::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ParameterValue (*this, f, c);
    }

    ParameterValue& ParameterValue::
    operator= (const ParameterValue& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->aDouble_ = x.aDouble_;
        this->anInteger_ = x.anInteger_;
        this->aBool_ = x.aBool_;
        this->aString_ = x.aString_;
        this->aPath_ = x.aPath_;
        this->aVec3d_ = x.aVec3d_;
        this->aQuat_ = x.aQuat_;
        this->aMatrixd_ = x.aMatrixd_;
      }

      return *this;
    }

    ParameterValue::
    ~ParameterValue ()
    {
    }

    // Parameter
    //

    const Parameter::NameType Parameter::name_default_value_ (
      "Name");

    const Parameter::IdType Parameter::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    Parameter::
    Parameter (const NameType& name,
               const ConstantType& constant,
               const IdType& id)
    : ::xml_schema::Type (),
      name_ (name, this),
      constant_ (constant, this),
      value_ (this),
      id_ (id, this),
      pValue_ (this)
    {
    }

    Parameter::
    Parameter (const Parameter& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      name_ (x.name_, f, this),
      constant_ (x.constant_, f, this),
      value_ (x.value_, f, this),
      id_ (x.id_, f, this),
      pValue_ (x.pValue_, f, this)
    {
    }

    Parameter::
    Parameter (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      name_ (this),
      constant_ (this),
      value_ (this),
      id_ (this),
      pValue_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Parameter::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // name
        //
        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< NameType > r (
            NameTraits::create (i, f, this));

          if (!name_.present ())
          {
            this->name_.set (::std::move (r));
            continue;
          }
        }

        // constant
        //
        if (n.name () == "constant" && n.namespace_ ().empty ())
        {
          if (!constant_.present ())
          {
            this->constant_.set (ConstantTraits::create (i, f, this));
            continue;
          }
        }

        // value
        //
        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          if (!this->value_)
          {
            this->value_.set (ValueTraits::create (i, f, this));
            continue;
          }
        }

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          if (!id_.present ())
          {
            this->id_.set (::std::move (r));
            continue;
          }
        }

        // pValue
        //
        if (n.name () == "pValue" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< PValueType > r (
            PValueTraits::create (i, f, this));

          if (!this->pValue_)
          {
            this->pValue_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!constant_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "constant",
          "");
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }
    }

    Parameter* Parameter::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Parameter (*this, f, c);
    }

    Parameter& Parameter::
    operator= (const Parameter& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->name_ = x.name_;
        this->constant_ = x.constant_;
        this->value_ = x.value_;
        this->id_ = x.id_;
        this->pValue_ = x.pValue_;
      }

      return *this;
    }

    Parameter::
    ~Parameter ()
    {
    }

    // EvolveRecord
    //

    const EvolveRecord::IdInType EvolveRecord::idIn_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    const EvolveRecord::IdOutType EvolveRecord::idOut_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    EvolveRecord::
    EvolveRecord (const IdInType& idIn,
                  const IdOutType& idOut)
    : ::xml_schema::Type (),
      idIn_ (idIn, this),
      idOut_ (idOut, this)
    {
    }

    EvolveRecord::
    EvolveRecord (const EvolveRecord& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      idIn_ (x.idIn_, f, this),
      idOut_ (x.idOut_, f, this)
    {
    }

    EvolveRecord::
    EvolveRecord (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      idIn_ (this),
      idOut_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EvolveRecord::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // idIn
        //
        if (n.name () == "idIn" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdInType > r (
            IdInTraits::create (i, f, this));

          if (!idIn_.present ())
          {
            this->idIn_.set (::std::move (r));
            continue;
          }
        }

        // idOut
        //
        if (n.name () == "idOut" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdOutType > r (
            IdOutTraits::create (i, f, this));

          if (!idOut_.present ())
          {
            this->idOut_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!idIn_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "idIn",
          "");
      }

      if (!idOut_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "idOut",
          "");
      }
    }

    EvolveRecord* EvolveRecord::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EvolveRecord (*this, f, c);
    }

    EvolveRecord& EvolveRecord::
    operator= (const EvolveRecord& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->idIn_ = x.idIn_;
        this->idOut_ = x.idOut_;
      }

      return *this;
    }

    EvolveRecord::
    ~EvolveRecord ()
    {
    }

    // EvolveContainer
    //

    EvolveContainer::
    EvolveContainer ()
    : ::xml_schema::Type (),
      evolveRecord_ (this)
    {
    }

    EvolveContainer::
    EvolveContainer (const EvolveContainer& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      evolveRecord_ (x.evolveRecord_, f, this)
    {
    }

    EvolveContainer::
    EvolveContainer (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      evolveRecord_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EvolveContainer::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // evolveRecord
        //
        if (n.name () == "evolveRecord" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< EvolveRecordType > r (
            EvolveRecordTraits::create (i, f, this));

          this->evolveRecord_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    EvolveContainer* EvolveContainer::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EvolveContainer (*this, f, c);
    }

    EvolveContainer& EvolveContainer::
    operator= (const EvolveContainer& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->evolveRecord_ = x.evolveRecord_;
      }

      return *this;
    }

    EvolveContainer::
    ~EvolveContainer ()
    {
    }

    // ShapeIdRecord
    //

    const ShapeIdRecord::IdType ShapeIdRecord::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    ShapeIdRecord::
    ShapeIdRecord (const IdType& id,
                   const ShapeOffsetType& shapeOffset)
    : ::xml_schema::Type (),
      id_ (id, this),
      shapeOffset_ (shapeOffset, this)
    {
    }

    ShapeIdRecord::
    ShapeIdRecord (const ShapeIdRecord& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this),
      shapeOffset_ (x.shapeOffset_, f, this)
    {
    }

    ShapeIdRecord::
    ShapeIdRecord (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this),
      shapeOffset_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ShapeIdRecord::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          if (!id_.present ())
          {
            this->id_.set (::std::move (r));
            continue;
          }
        }

        // shapeOffset
        //
        if (n.name () == "shapeOffset" && n.namespace_ ().empty ())
        {
          if (!shapeOffset_.present ())
          {
            this->shapeOffset_.set (ShapeOffsetTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!shapeOffset_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "shapeOffset",
          "");
      }
    }

    ShapeIdRecord* ShapeIdRecord::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ShapeIdRecord (*this, f, c);
    }

    ShapeIdRecord& ShapeIdRecord::
    operator= (const ShapeIdRecord& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
        this->shapeOffset_ = x.shapeOffset_;
      }

      return *this;
    }

    ShapeIdRecord::
    ~ShapeIdRecord ()
    {
    }

    // ShapeIdContainer
    //

    ShapeIdContainer::
    ShapeIdContainer ()
    : ::xml_schema::Type (),
      shapeIdRecord_ (this)
    {
    }

    ShapeIdContainer::
    ShapeIdContainer (const ShapeIdContainer& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      shapeIdRecord_ (x.shapeIdRecord_, f, this)
    {
    }

    ShapeIdContainer::
    ShapeIdContainer (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      shapeIdRecord_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ShapeIdContainer::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // shapeIdRecord
        //
        if (n.name () == "shapeIdRecord" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ShapeIdRecordType > r (
            ShapeIdRecordTraits::create (i, f, this));

          this->shapeIdRecord_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    ShapeIdContainer* ShapeIdContainer::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ShapeIdContainer (*this, f, c);
    }

    ShapeIdContainer& ShapeIdContainer::
    operator= (const ShapeIdContainer& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->shapeIdRecord_ = x.shapeIdRecord_;
      }

      return *this;
    }

    ShapeIdContainer::
    ~ShapeIdContainer ()
    {
    }

    // FeatureTagRecord
    //

    const FeatureTagRecord::IdType FeatureTagRecord::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    const FeatureTagRecord::TagType FeatureTagRecord::tag_default_value_ (
      "");

    FeatureTagRecord::
    FeatureTagRecord (const IdType& id,
                      const TagType& tag)
    : ::xml_schema::Type (),
      id_ (id, this),
      tag_ (tag, this)
    {
    }

    FeatureTagRecord::
    FeatureTagRecord (const FeatureTagRecord& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this),
      tag_ (x.tag_, f, this)
    {
    }

    FeatureTagRecord::
    FeatureTagRecord (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this),
      tag_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureTagRecord::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          if (!id_.present ())
          {
            this->id_.set (::std::move (r));
            continue;
          }
        }

        // tag
        //
        if (n.name () == "tag" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< TagType > r (
            TagTraits::create (i, f, this));

          if (!tag_.present ())
          {
            this->tag_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!tag_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "tag",
          "");
      }
    }

    FeatureTagRecord* FeatureTagRecord::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FeatureTagRecord (*this, f, c);
    }

    FeatureTagRecord& FeatureTagRecord::
    operator= (const FeatureTagRecord& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
        this->tag_ = x.tag_;
      }

      return *this;
    }

    FeatureTagRecord::
    ~FeatureTagRecord ()
    {
    }

    // FeatureTagContainer
    //

    FeatureTagContainer::
    FeatureTagContainer ()
    : ::xml_schema::Type (),
      featureTagRecord_ (this)
    {
    }

    FeatureTagContainer::
    FeatureTagContainer (const FeatureTagContainer& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      featureTagRecord_ (x.featureTagRecord_, f, this)
    {
    }

    FeatureTagContainer::
    FeatureTagContainer (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      featureTagRecord_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureTagContainer::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // featureTagRecord
        //
        if (n.name () == "featureTagRecord" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< FeatureTagRecordType > r (
            FeatureTagRecordTraits::create (i, f, this));

          this->featureTagRecord_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    FeatureTagContainer* FeatureTagContainer::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FeatureTagContainer (*this, f, c);
    }

    FeatureTagContainer& FeatureTagContainer::
    operator= (const FeatureTagContainer& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->featureTagRecord_ = x.featureTagRecord_;
      }

      return *this;
    }

    FeatureTagContainer::
    ~FeatureTagContainer ()
    {
    }

    // IdSet
    //

    const IdSet::IdType IdSet::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    IdSet::
    IdSet ()
    : ::xml_schema::Type (),
      id_ (this)
    {
    }

    IdSet::
    IdSet (const IdSet& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this)
    {
    }

    IdSet::
    IdSet (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void IdSet::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->id_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    IdSet* IdSet::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IdSet (*this, f, c);
    }

    IdSet& IdSet::
    operator= (const IdSet& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
      }

      return *this;
    }

    IdSet::
    ~IdSet ()
    {
    }

    // DerivedRecord
    //

    const DerivedRecord::IdType DerivedRecord::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    DerivedRecord::
    DerivedRecord (const IdSetType& idSet,
                   const IdType& id)
    : ::xml_schema::Type (),
      idSet_ (idSet, this),
      id_ (id, this)
    {
    }

    DerivedRecord::
    DerivedRecord (::std::unique_ptr< IdSetType > idSet,
                   const IdType& id)
    : ::xml_schema::Type (),
      idSet_ (std::move (idSet), this),
      id_ (id, this)
    {
    }

    DerivedRecord::
    DerivedRecord (const DerivedRecord& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      idSet_ (x.idSet_, f, this),
      id_ (x.id_, f, this)
    {
    }

    DerivedRecord::
    DerivedRecord (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      idSet_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DerivedRecord::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // idSet
        //
        if (n.name () == "idSet" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdSetType > r (
            IdSetTraits::create (i, f, this));

          if (!idSet_.present ())
          {
            this->idSet_.set (::std::move (r));
            continue;
          }
        }

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          if (!id_.present ())
          {
            this->id_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!idSet_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "idSet",
          "");
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }
    }

    DerivedRecord* DerivedRecord::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DerivedRecord (*this, f, c);
    }

    DerivedRecord& DerivedRecord::
    operator= (const DerivedRecord& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->idSet_ = x.idSet_;
        this->id_ = x.id_;
      }

      return *this;
    }

    DerivedRecord::
    ~DerivedRecord ()
    {
    }

    // DerivedContainer
    //

    DerivedContainer::
    DerivedContainer ()
    : ::xml_schema::Type (),
      derivedRecord_ (this)
    {
    }

    DerivedContainer::
    DerivedContainer (const DerivedContainer& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      derivedRecord_ (x.derivedRecord_, f, this)
    {
    }

    DerivedContainer::
    DerivedContainer (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      derivedRecord_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DerivedContainer::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // derivedRecord
        //
        if (n.name () == "derivedRecord" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< DerivedRecordType > r (
            DerivedRecordTraits::create (i, f, this));

          this->derivedRecord_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    DerivedContainer* DerivedContainer::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DerivedContainer (*this, f, c);
    }

    DerivedContainer& DerivedContainer::
    operator= (const DerivedContainer& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->derivedRecord_ = x.derivedRecord_;
      }

      return *this;
    }

    DerivedContainer::
    ~DerivedContainer ()
    {
    }

    // SeerShape
    //

    const SeerShape::RootShapeIdType SeerShape::rootShapeId_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    SeerShape::
    SeerShape (const RootShapeIdType& rootShapeId,
               const ShapeIdContainerType& shapeIdContainer,
               const EvolveContainerType& evolveContainer,
               const FeatureTagContainerType& featureTagContainer,
               const DerivedContainerType& derivedContainer)
    : ::xml_schema::Type (),
      rootShapeId_ (rootShapeId, this),
      shapeIdContainer_ (shapeIdContainer, this),
      evolveContainer_ (evolveContainer, this),
      featureTagContainer_ (featureTagContainer, this),
      derivedContainer_ (derivedContainer, this)
    {
    }

    SeerShape::
    SeerShape (const RootShapeIdType& rootShapeId,
               ::std::unique_ptr< ShapeIdContainerType > shapeIdContainer,
               ::std::unique_ptr< EvolveContainerType > evolveContainer,
               ::std::unique_ptr< FeatureTagContainerType > featureTagContainer,
               ::std::unique_ptr< DerivedContainerType > derivedContainer)
    : ::xml_schema::Type (),
      rootShapeId_ (rootShapeId, this),
      shapeIdContainer_ (std::move (shapeIdContainer), this),
      evolveContainer_ (std::move (evolveContainer), this),
      featureTagContainer_ (std::move (featureTagContainer), this),
      derivedContainer_ (std::move (derivedContainer), this)
    {
    }

    SeerShape::
    SeerShape (const SeerShape& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      rootShapeId_ (x.rootShapeId_, f, this),
      shapeIdContainer_ (x.shapeIdContainer_, f, this),
      evolveContainer_ (x.evolveContainer_, f, this),
      featureTagContainer_ (x.featureTagContainer_, f, this),
      derivedContainer_ (x.derivedContainer_, f, this)
    {
    }

    SeerShape::
    SeerShape (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      rootShapeId_ (this),
      shapeIdContainer_ (this),
      evolveContainer_ (this),
      featureTagContainer_ (this),
      derivedContainer_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SeerShape::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // rootShapeId
        //
        if (n.name () == "rootShapeId" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< RootShapeIdType > r (
            RootShapeIdTraits::create (i, f, this));

          if (!rootShapeId_.present ())
          {
            this->rootShapeId_.set (::std::move (r));
            continue;
          }
        }

        // shapeIdContainer
        //
        if (n.name () == "shapeIdContainer" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ShapeIdContainerType > r (
            ShapeIdContainerTraits::create (i, f, this));

          if (!shapeIdContainer_.present ())
          {
            this->shapeIdContainer_.set (::std::move (r));
            continue;
          }
        }

        // evolveContainer
        //
        if (n.name () == "evolveContainer" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< EvolveContainerType > r (
            EvolveContainerTraits::create (i, f, this));

          if (!evolveContainer_.present ())
          {
            this->evolveContainer_.set (::std::move (r));
            continue;
          }
        }

        // featureTagContainer
        //
        if (n.name () == "featureTagContainer" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< FeatureTagContainerType > r (
            FeatureTagContainerTraits::create (i, f, this));

          if (!featureTagContainer_.present ())
          {
            this->featureTagContainer_.set (::std::move (r));
            continue;
          }
        }

        // derivedContainer
        //
        if (n.name () == "derivedContainer" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< DerivedContainerType > r (
            DerivedContainerTraits::create (i, f, this));

          if (!derivedContainer_.present ())
          {
            this->derivedContainer_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!rootShapeId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "rootShapeId",
          "");
      }

      if (!shapeIdContainer_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "shapeIdContainer",
          "");
      }

      if (!evolveContainer_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "evolveContainer",
          "");
      }

      if (!featureTagContainer_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "featureTagContainer",
          "");
      }

      if (!derivedContainer_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "derivedContainer",
          "");
      }
    }

    SeerShape* SeerShape::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SeerShape (*this, f, c);
    }

    SeerShape& SeerShape::
    operator= (const SeerShape& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->rootShapeId_ = x.rootShapeId_;
        this->shapeIdContainer_ = x.shapeIdContainer_;
        this->evolveContainer_ = x.evolveContainer_;
        this->featureTagContainer_ = x.featureTagContainer_;
        this->derivedContainer_ = x.derivedContainer_;
      }

      return *this;
    }

    SeerShape::
    ~SeerShape ()
    {
    }

    // EdgeNode
    //

    const EdgeNode::EdgeIdType EdgeNode::edgeId_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    EdgeNode::
    EdgeNode (const EdgeIdType& edgeId,
              const CenterType& center,
              const AliveType& alive)
    : ::xml_schema::Type (),
      edgeId_ (edgeId, this),
      center_ (center, this),
      alive_ (alive, this)
    {
    }

    EdgeNode::
    EdgeNode (const EdgeNode& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      edgeId_ (x.edgeId_, f, this),
      center_ (x.center_, f, this),
      alive_ (x.alive_, f, this)
    {
    }

    EdgeNode::
    EdgeNode (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      edgeId_ (this),
      center_ (this),
      alive_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgeNode::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // edgeId
        //
        if (n.name () == "edgeId" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< EdgeIdType > r (
            EdgeIdTraits::create (i, f, this));

          if (!edgeId_.present ())
          {
            this->edgeId_.set (::std::move (r));
            continue;
          }
        }

        // center
        //
        if (n.name () == "center" && n.namespace_ ().empty ())
        {
          if (!center_.present ())
          {
            this->center_.set (CenterTraits::create (i, f, this));
            continue;
          }
        }

        // alive
        //
        if (n.name () == "alive" && n.namespace_ ().empty ())
        {
          if (!alive_.present ())
          {
            this->alive_.set (AliveTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!edgeId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "edgeId",
          "");
      }

      if (!center_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "center",
          "");
      }

      if (!alive_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "alive",
          "");
      }
    }

    EdgeNode* EdgeNode::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EdgeNode (*this, f, c);
    }

    EdgeNode& EdgeNode::
    operator= (const EdgeNode& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->edgeId_ = x.edgeId_;
        this->center_ = x.center_;
        this->alive_ = x.alive_;
      }

      return *this;
    }

    EdgeNode::
    ~EdgeNode ()
    {
    }

    // EdgeNodes
    //

    EdgeNodes::
    EdgeNodes ()
    : ::xml_schema::Type (),
      array_ (this)
    {
    }

    EdgeNodes::
    EdgeNodes (const EdgeNodes& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      array_ (x.array_, f, this)
    {
    }

    EdgeNodes::
    EdgeNodes (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      array_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgeNodes::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // array
        //
        if (n.name () == "array" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ArrayType > r (
            ArrayTraits::create (i, f, this));

          this->array_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    EdgeNodes* EdgeNodes::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EdgeNodes (*this, f, c);
    }

    EdgeNodes& EdgeNodes::
    operator= (const EdgeNodes& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->array_ = x.array_;
      }

      return *this;
    }

    EdgeNodes::
    ~EdgeNodes ()
    {
    }

    // EdgeSplit
    //

    EdgeSplit::
    EdgeSplit (const EdgeHistoryType& edgeHistory,
               const NodesType& nodes)
    : ::xml_schema::Type (),
      edgeHistory_ (edgeHistory, this),
      nodes_ (nodes, this)
    {
    }

    EdgeSplit::
    EdgeSplit (::std::unique_ptr< EdgeHistoryType > edgeHistory,
               ::std::unique_ptr< NodesType > nodes)
    : ::xml_schema::Type (),
      edgeHistory_ (std::move (edgeHistory), this),
      nodes_ (std::move (nodes), this)
    {
    }

    EdgeSplit::
    EdgeSplit (const EdgeSplit& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      edgeHistory_ (x.edgeHistory_, f, this),
      nodes_ (x.nodes_, f, this)
    {
    }

    EdgeSplit::
    EdgeSplit (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      edgeHistory_ (this),
      nodes_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgeSplit::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // edgeHistory
        //
        if (n.name () == "edgeHistory" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< EdgeHistoryType > r (
            EdgeHistoryTraits::create (i, f, this));

          if (!edgeHistory_.present ())
          {
            this->edgeHistory_.set (::std::move (r));
            continue;
          }
        }

        // nodes
        //
        if (n.name () == "nodes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< NodesType > r (
            NodesTraits::create (i, f, this));

          if (!nodes_.present ())
          {
            this->nodes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!edgeHistory_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "edgeHistory",
          "");
      }

      if (!nodes_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "nodes",
          "");
      }
    }

    EdgeSplit* EdgeSplit::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EdgeSplit (*this, f, c);
    }

    EdgeSplit& EdgeSplit::
    operator= (const EdgeSplit& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->edgeHistory_ = x.edgeHistory_;
        this->nodes_ = x.nodes_;
      }

      return *this;
    }

    EdgeSplit::
    ~EdgeSplit ()
    {
    }

    // EdgeSplits
    //

    EdgeSplits::
    EdgeSplits ()
    : ::xml_schema::Type (),
      array_ (this)
    {
    }

    EdgeSplits::
    EdgeSplits (const EdgeSplits& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      array_ (x.array_, f, this)
    {
    }

    EdgeSplits::
    EdgeSplits (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      array_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgeSplits::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // array
        //
        if (n.name () == "array" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ArrayType > r (
            ArrayTraits::create (i, f, this));

          this->array_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    EdgeSplits* EdgeSplits::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EdgeSplits (*this, f, c);
    }

    EdgeSplits& EdgeSplits::
    operator= (const EdgeSplits& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->array_ = x.array_;
      }

      return *this;
    }

    EdgeSplits::
    ~EdgeSplits ()
    {
    }

    // IntersectionNode
    //

    const IntersectionNode::EdgeIdType IntersectionNode::edgeId_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    IntersectionNode::
    IntersectionNode (const EdgeIdType& edgeId,
                      const CenterXType& centerX,
                      const CenterYType& centerY,
                      const AliveType& alive)
    : ::xml_schema::Type (),
      edgeId_ (edgeId, this),
      centerX_ (centerX, this),
      centerY_ (centerY, this),
      alive_ (alive, this)
    {
    }

    IntersectionNode::
    IntersectionNode (const IntersectionNode& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      edgeId_ (x.edgeId_, f, this),
      centerX_ (x.centerX_, f, this),
      centerY_ (x.centerY_, f, this),
      alive_ (x.alive_, f, this)
    {
    }

    IntersectionNode::
    IntersectionNode (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      edgeId_ (this),
      centerX_ (this),
      centerY_ (this),
      alive_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void IntersectionNode::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // edgeId
        //
        if (n.name () == "edgeId" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< EdgeIdType > r (
            EdgeIdTraits::create (i, f, this));

          if (!edgeId_.present ())
          {
            this->edgeId_.set (::std::move (r));
            continue;
          }
        }

        // centerX
        //
        if (n.name () == "centerX" && n.namespace_ ().empty ())
        {
          if (!centerX_.present ())
          {
            this->centerX_.set (CenterXTraits::create (i, f, this));
            continue;
          }
        }

        // centerY
        //
        if (n.name () == "centerY" && n.namespace_ ().empty ())
        {
          if (!centerY_.present ())
          {
            this->centerY_.set (CenterYTraits::create (i, f, this));
            continue;
          }
        }

        // alive
        //
        if (n.name () == "alive" && n.namespace_ ().empty ())
        {
          if (!alive_.present ())
          {
            this->alive_.set (AliveTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!edgeId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "edgeId",
          "");
      }

      if (!centerX_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "centerX",
          "");
      }

      if (!centerY_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "centerY",
          "");
      }

      if (!alive_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "alive",
          "");
      }
    }

    IntersectionNode* IntersectionNode::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IntersectionNode (*this, f, c);
    }

    IntersectionNode& IntersectionNode::
    operator= (const IntersectionNode& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->edgeId_ = x.edgeId_;
        this->centerX_ = x.centerX_;
        this->centerY_ = x.centerY_;
        this->alive_ = x.alive_;
      }

      return *this;
    }

    IntersectionNode::
    ~IntersectionNode ()
    {
    }

    // IntersectionNodes
    //

    IntersectionNodes::
    IntersectionNodes ()
    : ::xml_schema::Type (),
      array_ (this)
    {
    }

    IntersectionNodes::
    IntersectionNodes (const IntersectionNodes& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      array_ (x.array_, f, this)
    {
    }

    IntersectionNodes::
    IntersectionNodes (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      array_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void IntersectionNodes::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // array
        //
        if (n.name () == "array" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ArrayType > r (
            ArrayTraits::create (i, f, this));

          this->array_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    IntersectionNodes* IntersectionNodes::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IntersectionNodes (*this, f, c);
    }

    IntersectionNodes& IntersectionNodes::
    operator= (const IntersectionNodes& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->array_ = x.array_;
      }

      return *this;
    }

    IntersectionNodes::
    ~IntersectionNodes ()
    {
    }

    // EdgeIntersection
    //

    EdgeIntersection::
    EdgeIntersection (const FaceHistory1Type& faceHistory1,
                      const FaceHistory2Type& faceHistory2,
                      const NodesType& nodes)
    : ::xml_schema::Type (),
      faceHistory1_ (faceHistory1, this),
      faceHistory2_ (faceHistory2, this),
      nodes_ (nodes, this)
    {
    }

    EdgeIntersection::
    EdgeIntersection (::std::unique_ptr< FaceHistory1Type > faceHistory1,
                      ::std::unique_ptr< FaceHistory2Type > faceHistory2,
                      ::std::unique_ptr< NodesType > nodes)
    : ::xml_schema::Type (),
      faceHistory1_ (std::move (faceHistory1), this),
      faceHistory2_ (std::move (faceHistory2), this),
      nodes_ (std::move (nodes), this)
    {
    }

    EdgeIntersection::
    EdgeIntersection (const EdgeIntersection& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      faceHistory1_ (x.faceHistory1_, f, this),
      faceHistory2_ (x.faceHistory2_, f, this),
      nodes_ (x.nodes_, f, this)
    {
    }

    EdgeIntersection::
    EdgeIntersection (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      faceHistory1_ (this),
      faceHistory2_ (this),
      nodes_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgeIntersection::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // faceHistory1
        //
        if (n.name () == "faceHistory1" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< FaceHistory1Type > r (
            FaceHistory1Traits::create (i, f, this));

          if (!faceHistory1_.present ())
          {
            this->faceHistory1_.set (::std::move (r));
            continue;
          }
        }

        // faceHistory2
        //
        if (n.name () == "faceHistory2" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< FaceHistory2Type > r (
            FaceHistory2Traits::create (i, f, this));

          if (!faceHistory2_.present ())
          {
            this->faceHistory2_.set (::std::move (r));
            continue;
          }
        }

        // nodes
        //
        if (n.name () == "nodes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< NodesType > r (
            NodesTraits::create (i, f, this));

          if (!nodes_.present ())
          {
            this->nodes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!faceHistory1_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "faceHistory1",
          "");
      }

      if (!faceHistory2_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "faceHistory2",
          "");
      }

      if (!nodes_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "nodes",
          "");
      }
    }

    EdgeIntersection* EdgeIntersection::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EdgeIntersection (*this, f, c);
    }

    EdgeIntersection& EdgeIntersection::
    operator= (const EdgeIntersection& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->faceHistory1_ = x.faceHistory1_;
        this->faceHistory2_ = x.faceHistory2_;
        this->nodes_ = x.nodes_;
      }

      return *this;
    }

    EdgeIntersection::
    ~EdgeIntersection ()
    {
    }

    // EdgeIntersections
    //

    EdgeIntersections::
    EdgeIntersections ()
    : ::xml_schema::Type (),
      array_ (this)
    {
    }

    EdgeIntersections::
    EdgeIntersections (const EdgeIntersections& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      array_ (x.array_, f, this)
    {
    }

    EdgeIntersections::
    EdgeIntersections (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      array_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgeIntersections::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // array
        //
        if (n.name () == "array" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ArrayType > r (
            ArrayTraits::create (i, f, this));

          this->array_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    EdgeIntersections* EdgeIntersections::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EdgeIntersections (*this, f, c);
    }

    EdgeIntersections& EdgeIntersections::
    operator= (const EdgeIntersections& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->array_ = x.array_;
      }

      return *this;
    }

    EdgeIntersections::
    ~EdgeIntersections ()
    {
    }

    // FaceNode
    //

    const FaceNode::FaceIdType FaceNode::faceId_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    const FaceNode::WireIdType FaceNode::wireId_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    FaceNode::
    FaceNode (const FaceIdType& faceId,
              const WireIdType& wireId,
              const CenterXType& centerX,
              const CenterYType& centerY,
              const AliveType& alive)
    : ::xml_schema::Type (),
      faceId_ (faceId, this),
      wireId_ (wireId, this),
      centerX_ (centerX, this),
      centerY_ (centerY, this),
      alive_ (alive, this)
    {
    }

    FaceNode::
    FaceNode (const FaceNode& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      faceId_ (x.faceId_, f, this),
      wireId_ (x.wireId_, f, this),
      centerX_ (x.centerX_, f, this),
      centerY_ (x.centerY_, f, this),
      alive_ (x.alive_, f, this)
    {
    }

    FaceNode::
    FaceNode (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      faceId_ (this),
      wireId_ (this),
      centerX_ (this),
      centerY_ (this),
      alive_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FaceNode::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // faceId
        //
        if (n.name () == "faceId" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< FaceIdType > r (
            FaceIdTraits::create (i, f, this));

          if (!faceId_.present ())
          {
            this->faceId_.set (::std::move (r));
            continue;
          }
        }

        // wireId
        //
        if (n.name () == "wireId" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< WireIdType > r (
            WireIdTraits::create (i, f, this));

          if (!wireId_.present ())
          {
            this->wireId_.set (::std::move (r));
            continue;
          }
        }

        // centerX
        //
        if (n.name () == "centerX" && n.namespace_ ().empty ())
        {
          if (!centerX_.present ())
          {
            this->centerX_.set (CenterXTraits::create (i, f, this));
            continue;
          }
        }

        // centerY
        //
        if (n.name () == "centerY" && n.namespace_ ().empty ())
        {
          if (!centerY_.present ())
          {
            this->centerY_.set (CenterYTraits::create (i, f, this));
            continue;
          }
        }

        // alive
        //
        if (n.name () == "alive" && n.namespace_ ().empty ())
        {
          if (!alive_.present ())
          {
            this->alive_.set (AliveTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!faceId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "faceId",
          "");
      }

      if (!wireId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "wireId",
          "");
      }

      if (!centerX_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "centerX",
          "");
      }

      if (!centerY_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "centerY",
          "");
      }

      if (!alive_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "alive",
          "");
      }
    }

    FaceNode* FaceNode::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FaceNode (*this, f, c);
    }

    FaceNode& FaceNode::
    operator= (const FaceNode& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->faceId_ = x.faceId_;
        this->wireId_ = x.wireId_;
        this->centerX_ = x.centerX_;
        this->centerY_ = x.centerY_;
        this->alive_ = x.alive_;
      }

      return *this;
    }

    FaceNode::
    ~FaceNode ()
    {
    }

    // FaceNodes
    //

    FaceNodes::
    FaceNodes ()
    : ::xml_schema::Type (),
      array_ (this)
    {
    }

    FaceNodes::
    FaceNodes (const FaceNodes& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      array_ (x.array_, f, this)
    {
    }

    FaceNodes::
    FaceNodes (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      array_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FaceNodes::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // array
        //
        if (n.name () == "array" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ArrayType > r (
            ArrayTraits::create (i, f, this));

          this->array_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    FaceNodes* FaceNodes::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FaceNodes (*this, f, c);
    }

    FaceNodes& FaceNodes::
    operator= (const FaceNodes& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->array_ = x.array_;
      }

      return *this;
    }

    FaceNodes::
    ~FaceNodes ()
    {
    }

    // FaceSplit
    //

    FaceSplit::
    FaceSplit (const FaceHistoryType& faceHistory,
               const NodesType& nodes)
    : ::xml_schema::Type (),
      faceHistory_ (faceHistory, this),
      nodes_ (nodes, this)
    {
    }

    FaceSplit::
    FaceSplit (::std::unique_ptr< FaceHistoryType > faceHistory,
               ::std::unique_ptr< NodesType > nodes)
    : ::xml_schema::Type (),
      faceHistory_ (std::move (faceHistory), this),
      nodes_ (std::move (nodes), this)
    {
    }

    FaceSplit::
    FaceSplit (const FaceSplit& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      faceHistory_ (x.faceHistory_, f, this),
      nodes_ (x.nodes_, f, this)
    {
    }

    FaceSplit::
    FaceSplit (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      faceHistory_ (this),
      nodes_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FaceSplit::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // faceHistory
        //
        if (n.name () == "faceHistory" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< FaceHistoryType > r (
            FaceHistoryTraits::create (i, f, this));

          if (!faceHistory_.present ())
          {
            this->faceHistory_.set (::std::move (r));
            continue;
          }
        }

        // nodes
        //
        if (n.name () == "nodes" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< NodesType > r (
            NodesTraits::create (i, f, this));

          if (!nodes_.present ())
          {
            this->nodes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!faceHistory_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "faceHistory",
          "");
      }

      if (!nodes_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "nodes",
          "");
      }
    }

    FaceSplit* FaceSplit::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FaceSplit (*this, f, c);
    }

    FaceSplit& FaceSplit::
    operator= (const FaceSplit& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->faceHistory_ = x.faceHistory_;
        this->nodes_ = x.nodes_;
      }

      return *this;
    }

    FaceSplit::
    ~FaceSplit ()
    {
    }

    // FaceSplits
    //

    FaceSplits::
    FaceSplits ()
    : ::xml_schema::Type (),
      array_ (this)
    {
    }

    FaceSplits::
    FaceSplits (const FaceSplits& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      array_ (x.array_, f, this)
    {
    }

    FaceSplits::
    FaceSplits (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      array_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FaceSplits::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // array
        //
        if (n.name () == "array" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ArrayType > r (
            ArrayTraits::create (i, f, this));

          this->array_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    FaceSplits* FaceSplits::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FaceSplits (*this, f, c);
    }

    FaceSplits& FaceSplits::
    operator= (const FaceSplits& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->array_ = x.array_;
      }

      return *this;
    }

    FaceSplits::
    ~FaceSplits ()
    {
    }

    // SameDomain
    //

    const SameDomain::IdType SameDomain::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    SameDomain::
    SameDomain (const IdType& id,
                const HistoriesType& histories)
    : ::xml_schema::Type (),
      id_ (id, this),
      histories_ (histories, this)
    {
    }

    SameDomain::
    SameDomain (const IdType& id,
                ::std::unique_ptr< HistoriesType > histories)
    : ::xml_schema::Type (),
      id_ (id, this),
      histories_ (std::move (histories), this)
    {
    }

    SameDomain::
    SameDomain (const SameDomain& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this),
      histories_ (x.histories_, f, this)
    {
    }

    SameDomain::
    SameDomain (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this),
      histories_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SameDomain::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          if (!id_.present ())
          {
            this->id_.set (::std::move (r));
            continue;
          }
        }

        // histories
        //
        if (n.name () == "histories" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< HistoriesType > r (
            HistoriesTraits::create (i, f, this));

          if (!histories_.present ())
          {
            this->histories_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!histories_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "histories",
          "");
      }
    }

    SameDomain* SameDomain::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SameDomain (*this, f, c);
    }

    SameDomain& SameDomain::
    operator= (const SameDomain& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
        this->histories_ = x.histories_;
      }

      return *this;
    }

    SameDomain::
    ~SameDomain ()
    {
    }

    // SameDomains
    //

    SameDomains::
    SameDomains ()
    : ::xml_schema::Type (),
      array_ (this)
    {
    }

    SameDomains::
    SameDomains (const SameDomains& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      array_ (x.array_, f, this)
    {
    }

    SameDomains::
    SameDomains (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      array_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SameDomains::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // array
        //
        if (n.name () == "array" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ArrayType > r (
            ArrayTraits::create (i, f, this));

          this->array_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    SameDomains* SameDomains::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SameDomains (*this, f, c);
    }

    SameDomains& SameDomains::
    operator= (const SameDomains& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->array_ = x.array_;
      }

      return *this;
    }

    SameDomains::
    ~SameDomains ()
    {
    }

    // IntersectionMapper
    //

    IntersectionMapper::
    IntersectionMapper (const EdgeIntersectionsType& edgeIntersections,
                        const FaceSplitsType& faceSplits,
                        const EdgeSplitsType& edgeSplits,
                        const SameDomainsType& sameDomains)
    : ::xml_schema::Type (),
      edgeIntersections_ (edgeIntersections, this),
      faceSplits_ (faceSplits, this),
      edgeSplits_ (edgeSplits, this),
      sameDomains_ (sameDomains, this)
    {
    }

    IntersectionMapper::
    IntersectionMapper (::std::unique_ptr< EdgeIntersectionsType > edgeIntersections,
                        ::std::unique_ptr< FaceSplitsType > faceSplits,
                        ::std::unique_ptr< EdgeSplitsType > edgeSplits,
                        ::std::unique_ptr< SameDomainsType > sameDomains)
    : ::xml_schema::Type (),
      edgeIntersections_ (std::move (edgeIntersections), this),
      faceSplits_ (std::move (faceSplits), this),
      edgeSplits_ (std::move (edgeSplits), this),
      sameDomains_ (std::move (sameDomains), this)
    {
    }

    IntersectionMapper::
    IntersectionMapper (const IntersectionMapper& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      edgeIntersections_ (x.edgeIntersections_, f, this),
      faceSplits_ (x.faceSplits_, f, this),
      edgeSplits_ (x.edgeSplits_, f, this),
      sameDomains_ (x.sameDomains_, f, this)
    {
    }

    IntersectionMapper::
    IntersectionMapper (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      edgeIntersections_ (this),
      faceSplits_ (this),
      edgeSplits_ (this),
      sameDomains_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void IntersectionMapper::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // edgeIntersections
        //
        if (n.name () == "edgeIntersections" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< EdgeIntersectionsType > r (
            EdgeIntersectionsTraits::create (i, f, this));

          if (!edgeIntersections_.present ())
          {
            this->edgeIntersections_.set (::std::move (r));
            continue;
          }
        }

        // faceSplits
        //
        if (n.name () == "faceSplits" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< FaceSplitsType > r (
            FaceSplitsTraits::create (i, f, this));

          if (!faceSplits_.present ())
          {
            this->faceSplits_.set (::std::move (r));
            continue;
          }
        }

        // edgeSplits
        //
        if (n.name () == "edgeSplits" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< EdgeSplitsType > r (
            EdgeSplitsTraits::create (i, f, this));

          if (!edgeSplits_.present ())
          {
            this->edgeSplits_.set (::std::move (r));
            continue;
          }
        }

        // sameDomains
        //
        if (n.name () == "sameDomains" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< SameDomainsType > r (
            SameDomainsTraits::create (i, f, this));

          if (!sameDomains_.present ())
          {
            this->sameDomains_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!edgeIntersections_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "edgeIntersections",
          "");
      }

      if (!faceSplits_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "faceSplits",
          "");
      }

      if (!edgeSplits_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "edgeSplits",
          "");
      }

      if (!sameDomains_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "sameDomains",
          "");
      }
    }

    IntersectionMapper* IntersectionMapper::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IntersectionMapper (*this, f, c);
    }

    IntersectionMapper& IntersectionMapper::
    operator= (const IntersectionMapper& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->edgeIntersections_ = x.edgeIntersections_;
        this->faceSplits_ = x.faceSplits_;
        this->edgeSplits_ = x.edgeSplits_;
        this->sameDomains_ = x.sameDomains_;
      }

      return *this;
    }

    IntersectionMapper::
    ~IntersectionMapper ()
    {
    }

    // ColorValue
    //

    ColorValue::
    ColorValue (const ::xml_schema::Decimal& _xsd_Decimal_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (_xsd_Decimal_base)
    {
    }

    ColorValue::
    ColorValue (const ColorValue& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
    {
    }

    ColorValue::
    ColorValue (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
    {
    }

    ColorValue::
    ColorValue (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
    {
    }

    ColorValue::
    ColorValue (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
    {
    }

    ColorValue* ColorValue::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ColorValue (*this, f, c);
    }

    ColorValue::
    ~ColorValue ()
    {
    }

    // Color
    //

    Color::
    Color (const RType& r,
           const GType& g,
           const BType& b,
           const AType& a)
    : ::xml_schema::Type (),
      r_ (r, this),
      g_ (g, this),
      b_ (b, this),
      a_ (a, this)
    {
    }

    Color::
    Color (const Color& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      r_ (x.r_, f, this),
      g_ (x.g_, f, this),
      b_ (x.b_, f, this),
      a_ (x.a_, f, this)
    {
    }

    Color::
    Color (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      r_ (this),
      g_ (this),
      b_ (this),
      a_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Color::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // r
        //
        if (n.name () == "r" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< RType > r (
            RTraits::create (i, f, this));

          if (!r_.present ())
          {
            this->r_.set (::std::move (r));
            continue;
          }
        }

        // g
        //
        if (n.name () == "g" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< GType > r (
            GTraits::create (i, f, this));

          if (!g_.present ())
          {
            this->g_.set (::std::move (r));
            continue;
          }
        }

        // b
        //
        if (n.name () == "b" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< BType > r (
            BTraits::create (i, f, this));

          if (!b_.present ())
          {
            this->b_.set (::std::move (r));
            continue;
          }
        }

        // a
        //
        if (n.name () == "a" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< AType > r (
            ATraits::create (i, f, this));

          if (!a_.present ())
          {
            this->a_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!r_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "r",
          "");
      }

      if (!g_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "g",
          "");
      }

      if (!b_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "b",
          "");
      }

      if (!a_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "a",
          "");
      }
    }

    Color* Color::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Color (*this, f, c);
    }

    Color& Color::
    operator= (const Color& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->r_ = x.r_;
        this->g_ = x.g_;
        this->b_ = x.b_;
        this->a_ = x.a_;
      }

      return *this;
    }

    Color::
    ~Color ()
    {
    }

    // FeatureBase
    //

    const FeatureBase::NameType FeatureBase::name_default_value_ (
      "Empty");

    const FeatureBase::IdType FeatureBase::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    FeatureBase::
    FeatureBase (const NameType& name,
                 const IdType& id)
    : ::xml_schema::Type (),
      name_ (name, this),
      id_ (id, this),
      seerShape_ (this),
      intersectionMapper_ (this),
      color_ (this),
      state_ (this)
    {
    }

    FeatureBase::
    FeatureBase (const FeatureBase& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      name_ (x.name_, f, this),
      id_ (x.id_, f, this),
      seerShape_ (x.seerShape_, f, this),
      intersectionMapper_ (x.intersectionMapper_, f, this),
      color_ (x.color_, f, this),
      state_ (x.state_, f, this)
    {
    }

    FeatureBase::
    FeatureBase (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      name_ (this),
      id_ (this),
      seerShape_ (this),
      intersectionMapper_ (this),
      color_ (this),
      state_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureBase::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // name
        //
        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< NameType > r (
            NameTraits::create (i, f, this));

          if (!name_.present ())
          {
            this->name_.set (::std::move (r));
            continue;
          }
        }

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          if (!id_.present ())
          {
            this->id_.set (::std::move (r));
            continue;
          }
        }

        // seerShape
        //
        if (n.name () == "seerShape" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< SeerShapeType > r (
            SeerShapeTraits::create (i, f, this));

          if (!this->seerShape_)
          {
            this->seerShape_.set (::std::move (r));
            continue;
          }
        }

        // intersectionMapper
        //
        if (n.name () == "intersectionMapper" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IntersectionMapperType > r (
            IntersectionMapperTraits::create (i, f, this));

          if (!this->intersectionMapper_)
          {
            this->intersectionMapper_.set (::std::move (r));
            continue;
          }
        }

        // color
        //
        if (n.name () == "color" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ColorType > r (
            ColorTraits::create (i, f, this));

          if (!this->color_)
          {
            this->color_.set (::std::move (r));
            continue;
          }
        }

        // state
        //
        if (n.name () == "state" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< StateType > r (
            StateTraits::create (i, f, this));

          if (!this->state_)
          {
            this->state_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }
    }

    FeatureBase* FeatureBase::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FeatureBase (*this, f, c);
    }

    FeatureBase& FeatureBase::
    operator= (const FeatureBase& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->name_ = x.name_;
        this->id_ = x.id_;
        this->seerShape_ = x.seerShape_;
        this->intersectionMapper_ = x.intersectionMapper_;
        this->color_ = x.color_;
        this->state_ = x.state_;
      }

      return *this;
    }

    FeatureBase::
    ~FeatureBase ()
    {
    }

    // Pick
    //

    const Pick::IdType Pick::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    Pick::
    Pick (const IdType& id,
          const UType& u,
          const VType& v)
    : ::xml_schema::Type (),
      id_ (id, this),
      u_ (u, this),
      v_ (v, this),
      history_ (this)
    {
    }

    Pick::
    Pick (const Pick& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this),
      u_ (x.u_, f, this),
      v_ (x.v_, f, this),
      history_ (x.history_, f, this)
    {
    }

    Pick::
    Pick (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this),
      u_ (this),
      v_ (this),
      history_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Pick::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          if (!id_.present ())
          {
            this->id_.set (::std::move (r));
            continue;
          }
        }

        // u
        //
        if (n.name () == "u" && n.namespace_ ().empty ())
        {
          if (!u_.present ())
          {
            this->u_.set (UTraits::create (i, f, this));
            continue;
          }
        }

        // v
        //
        if (n.name () == "v" && n.namespace_ ().empty ())
        {
          if (!v_.present ())
          {
            this->v_.set (VTraits::create (i, f, this));
            continue;
          }
        }

        // history
        //
        if (n.name () == "history" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< HistoryType > r (
            HistoryTraits::create (i, f, this));

          if (!this->history_)
          {
            this->history_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!u_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "u",
          "");
      }

      if (!v_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "v",
          "");
      }
    }

    Pick* Pick::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Pick (*this, f, c);
    }

    Pick& Pick::
    operator= (const Pick& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
        this->u_ = x.u_;
        this->v_ = x.v_;
        this->history_ = x.history_;
      }

      return *this;
    }

    Pick::
    ~Pick ()
    {
    }

    // Picks
    //

    Picks::
    Picks ()
    : ::xml_schema::Type (),
      array_ (this)
    {
    }

    Picks::
    Picks (const Picks& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      array_ (x.array_, f, this)
    {
    }

    Picks::
    Picks (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      array_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Picks::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // array
        //
        if (n.name () == "array" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ArrayType > r (
            ArrayTraits::create (i, f, this));

          this->array_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    Picks* Picks::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Picks (*this, f, c);
    }

    Picks& Picks::
    operator= (const Picks& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->array_ = x.array_;
      }

      return *this;
    }

    Picks::
    ~Picks ()
    {
    }

    // PLabel
    //

    PLabel::
    PLabel (const MatrixType& matrix,
            const ColorType& color)
    : ::xml_schema::Type (),
      matrix_ (matrix, this),
      color_ (color, this)
    {
    }

    PLabel::
    PLabel (::std::unique_ptr< MatrixType > matrix,
            ::std::unique_ptr< ColorType > color)
    : ::xml_schema::Type (),
      matrix_ (std::move (matrix), this),
      color_ (std::move (color), this)
    {
    }

    PLabel::
    PLabel (const PLabel& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      matrix_ (x.matrix_, f, this),
      color_ (x.color_, f, this)
    {
    }

    PLabel::
    PLabel (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      matrix_ (this),
      color_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PLabel::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // matrix
        //
        if (n.name () == "matrix" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< MatrixType > r (
            MatrixTraits::create (i, f, this));

          if (!matrix_.present ())
          {
            this->matrix_.set (::std::move (r));
            continue;
          }
        }

        // color
        //
        if (n.name () == "color" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ColorType > r (
            ColorTraits::create (i, f, this));

          if (!color_.present ())
          {
            this->color_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!matrix_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "matrix",
          "");
      }

      if (!color_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "color",
          "");
      }
    }

    PLabel* PLabel::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class PLabel (*this, f, c);
    }

    PLabel& PLabel::
    operator= (const PLabel& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->matrix_ = x.matrix_;
        this->color_ = x.color_;
      }

      return *this;
    }

    PLabel::
    ~PLabel ()
    {
    }

    // CSysDragger
    //

    const CSysDragger::FeatureIdType CSysDragger::featureId_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    CSysDragger::
    CSysDragger (const MatrixType& matrix,
                 const LinkedType& linked,
                 const FeatureIdType& featureId)
    : ::xml_schema::Type (),
      matrix_ (matrix, this),
      linked_ (linked, this),
      featureId_ (featureId, this)
    {
    }

    CSysDragger::
    CSysDragger (::std::unique_ptr< MatrixType > matrix,
                 const LinkedType& linked,
                 const FeatureIdType& featureId)
    : ::xml_schema::Type (),
      matrix_ (std::move (matrix), this),
      linked_ (linked, this),
      featureId_ (featureId, this)
    {
    }

    CSysDragger::
    CSysDragger (const CSysDragger& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      matrix_ (x.matrix_, f, this),
      linked_ (x.linked_, f, this),
      featureId_ (x.featureId_, f, this)
    {
    }

    CSysDragger::
    CSysDragger (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      matrix_ (this),
      linked_ (this),
      featureId_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CSysDragger::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // matrix
        //
        if (n.name () == "matrix" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< MatrixType > r (
            MatrixTraits::create (i, f, this));

          if (!matrix_.present ())
          {
            this->matrix_.set (::std::move (r));
            continue;
          }
        }

        // linked
        //
        if (n.name () == "linked" && n.namespace_ ().empty ())
        {
          if (!linked_.present ())
          {
            this->linked_.set (LinkedTraits::create (i, f, this));
            continue;
          }
        }

        // featureId
        //
        if (n.name () == "featureId" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< FeatureIdType > r (
            FeatureIdTraits::create (i, f, this));

          if (!featureId_.present ())
          {
            this->featureId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!matrix_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "matrix",
          "");
      }

      if (!linked_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "linked",
          "");
      }

      if (!featureId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "featureId",
          "");
      }
    }

    CSysDragger* CSysDragger::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CSysDragger (*this, f, c);
    }

    CSysDragger& CSysDragger::
    operator= (const CSysDragger& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->matrix_ = x.matrix_;
        this->linked_ = x.linked_;
        this->featureId_ = x.featureId_;
      }

      return *this;
    }

    CSysDragger::
    ~CSysDragger ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace prj
{
  namespace srl
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace prj
{
  namespace srl
  {
    void
    operator<< (::xercesc::DOMElement& e, const Vec3d& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // x
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "x",
            e));

        s << ::xml_schema::AsDouble(i.x ());
      }

      // y
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "y",
            e));

        s << ::xml_schema::AsDouble(i.y ());
      }

      // z
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "z",
            e));

        s << ::xml_schema::AsDouble(i.z ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Quat& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // x
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "x",
            e));

        s << ::xml_schema::AsDouble(i.x ());
      }

      // y
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "y",
            e));

        s << ::xml_schema::AsDouble(i.y ());
      }

      // z
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "z",
            e));

        s << ::xml_schema::AsDouble(i.z ());
      }

      // w
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "w",
            e));

        s << ::xml_schema::AsDouble(i.w ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Matrixd& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // i0j0
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "i0j0",
            e));

        s << ::xml_schema::AsDouble(i.i0j0 ());
      }

      // i0j1
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "i0j1",
            e));

        s << ::xml_schema::AsDouble(i.i0j1 ());
      }

      // i0j2
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "i0j2",
            e));

        s << ::xml_schema::AsDouble(i.i0j2 ());
      }

      // i0j3
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "i0j3",
            e));

        s << ::xml_schema::AsDouble(i.i0j3 ());
      }

      // i1j0
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "i1j0",
            e));

        s << ::xml_schema::AsDouble(i.i1j0 ());
      }

      // i1j1
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "i1j1",
            e));

        s << ::xml_schema::AsDouble(i.i1j1 ());
      }

      // i1j2
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "i1j2",
            e));

        s << ::xml_schema::AsDouble(i.i1j2 ());
      }

      // i1j3
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "i1j3",
            e));

        s << ::xml_schema::AsDouble(i.i1j3 ());
      }

      // i2j0
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "i2j0",
            e));

        s << ::xml_schema::AsDouble(i.i2j0 ());
      }

      // i2j1
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "i2j1",
            e));

        s << ::xml_schema::AsDouble(i.i2j1 ());
      }

      // i2j2
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "i2j2",
            e));

        s << ::xml_schema::AsDouble(i.i2j2 ());
      }

      // i2j3
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "i2j3",
            e));

        s << ::xml_schema::AsDouble(i.i2j3 ());
      }

      // i3j0
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "i3j0",
            e));

        s << ::xml_schema::AsDouble(i.i3j0 ());
      }

      // i3j1
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "i3j1",
            e));

        s << ::xml_schema::AsDouble(i.i3j1 ());
      }

      // i3j2
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "i3j2",
            e));

        s << ::xml_schema::AsDouble(i.i3j2 ());
      }

      // i3j3
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "i3j3",
            e));

        s << ::xml_schema::AsDouble(i.i3j3 ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ParameterValue& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // aDouble
      //
      if (i.aDouble ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "aDouble",
            e));

        s << ::xml_schema::AsDouble(*i.aDouble ());
      }

      // anInteger
      //
      if (i.anInteger ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "anInteger",
            e));

        s << *i.anInteger ();
      }

      // aBool
      //
      if (i.aBool ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "aBool",
            e));

        s << *i.aBool ();
      }

      // aString
      //
      if (i.aString ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "aString",
            e));

        s << *i.aString ();
      }

      // aPath
      //
      if (i.aPath ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "aPath",
            e));

        s << *i.aPath ();
      }

      // aVec3d
      //
      if (i.aVec3d ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "aVec3d",
            e));

        s << *i.aVec3d ();
      }

      // aQuat
      //
      if (i.aQuat ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "aQuat",
            e));

        s << *i.aQuat ();
      }

      // aMatrixd
      //
      if (i.aMatrixd ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "aMatrixd",
            e));

        s << *i.aMatrixd ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Parameter& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // name
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "name",
            e));

        s << i.name ();
      }

      // constant
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "constant",
            e));

        s << i.constant ();
      }

      // value
      //
      if (i.value ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "value",
            e));

        s << ::xml_schema::AsDouble(*i.value ());
      }

      // id
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << i.id ();
      }

      // pValue
      //
      if (i.pValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "pValue",
            e));

        s << *i.pValue ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EvolveRecord& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // idIn
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "idIn",
            e));

        s << i.idIn ();
      }

      // idOut
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "idOut",
            e));

        s << i.idOut ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EvolveContainer& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // evolveRecord
      //
      for (EvolveContainer::EvolveRecordConstIterator
           b (i.evolveRecord ().begin ()), n (i.evolveRecord ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "evolveRecord",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ShapeIdRecord& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // id
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << i.id ();
      }

      // shapeOffset
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "shapeOffset",
            e));

        s << i.shapeOffset ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ShapeIdContainer& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // shapeIdRecord
      //
      for (ShapeIdContainer::ShapeIdRecordConstIterator
           b (i.shapeIdRecord ().begin ()), n (i.shapeIdRecord ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "shapeIdRecord",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureTagRecord& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // id
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << i.id ();
      }

      // tag
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "tag",
            e));

        s << i.tag ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureTagContainer& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // featureTagRecord
      //
      for (FeatureTagContainer::FeatureTagRecordConstIterator
           b (i.featureTagRecord ().begin ()), n (i.featureTagRecord ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "featureTagRecord",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IdSet& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // id
      //
      for (IdSet::IdConstIterator
           b (i.id ().begin ()), n (i.id ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DerivedRecord& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // idSet
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "idSet",
            e));

        s << i.idSet ();
      }

      // id
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DerivedContainer& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // derivedRecord
      //
      for (DerivedContainer::DerivedRecordConstIterator
           b (i.derivedRecord ().begin ()), n (i.derivedRecord ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "derivedRecord",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SeerShape& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // rootShapeId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "rootShapeId",
            e));

        s << i.rootShapeId ();
      }

      // shapeIdContainer
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "shapeIdContainer",
            e));

        s << i.shapeIdContainer ();
      }

      // evolveContainer
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "evolveContainer",
            e));

        s << i.evolveContainer ();
      }

      // featureTagContainer
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "featureTagContainer",
            e));

        s << i.featureTagContainer ();
      }

      // derivedContainer
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "derivedContainer",
            e));

        s << i.derivedContainer ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EdgeNode& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // edgeId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "edgeId",
            e));

        s << i.edgeId ();
      }

      // center
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "center",
            e));

        s << ::xml_schema::AsDouble(i.center ());
      }

      // alive
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "alive",
            e));

        s << i.alive ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EdgeNodes& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // array
      //
      for (EdgeNodes::ArrayConstIterator
           b (i.array ().begin ()), n (i.array ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "array",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EdgeSplit& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // edgeHistory
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "edgeHistory",
            e));

        s << i.edgeHistory ();
      }

      // nodes
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "nodes",
            e));

        s << i.nodes ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EdgeSplits& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // array
      //
      for (EdgeSplits::ArrayConstIterator
           b (i.array ().begin ()), n (i.array ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "array",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IntersectionNode& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // edgeId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "edgeId",
            e));

        s << i.edgeId ();
      }

      // centerX
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "centerX",
            e));

        s << ::xml_schema::AsDouble(i.centerX ());
      }

      // centerY
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "centerY",
            e));

        s << ::xml_schema::AsDouble(i.centerY ());
      }

      // alive
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "alive",
            e));

        s << i.alive ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IntersectionNodes& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // array
      //
      for (IntersectionNodes::ArrayConstIterator
           b (i.array ().begin ()), n (i.array ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "array",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EdgeIntersection& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // faceHistory1
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "faceHistory1",
            e));

        s << i.faceHistory1 ();
      }

      // faceHistory2
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "faceHistory2",
            e));

        s << i.faceHistory2 ();
      }

      // nodes
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "nodes",
            e));

        s << i.nodes ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EdgeIntersections& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // array
      //
      for (EdgeIntersections::ArrayConstIterator
           b (i.array ().begin ()), n (i.array ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "array",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FaceNode& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // faceId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "faceId",
            e));

        s << i.faceId ();
      }

      // wireId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "wireId",
            e));

        s << i.wireId ();
      }

      // centerX
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "centerX",
            e));

        s << ::xml_schema::AsDouble(i.centerX ());
      }

      // centerY
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "centerY",
            e));

        s << ::xml_schema::AsDouble(i.centerY ());
      }

      // alive
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "alive",
            e));

        s << i.alive ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FaceNodes& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // array
      //
      for (FaceNodes::ArrayConstIterator
           b (i.array ().begin ()), n (i.array ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "array",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FaceSplit& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // faceHistory
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "faceHistory",
            e));

        s << i.faceHistory ();
      }

      // nodes
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "nodes",
            e));

        s << i.nodes ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FaceSplits& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // array
      //
      for (FaceSplits::ArrayConstIterator
           b (i.array ().begin ()), n (i.array ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "array",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SameDomain& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // id
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << i.id ();
      }

      // histories
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "histories",
            e));

        s << i.histories ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SameDomains& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // array
      //
      for (SameDomains::ArrayConstIterator
           b (i.array ().begin ()), n (i.array ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "array",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IntersectionMapper& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // edgeIntersections
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "edgeIntersections",
            e));

        s << i.edgeIntersections ();
      }

      // faceSplits
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "faceSplits",
            e));

        s << i.faceSplits ();
      }

      // edgeSplits
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "edgeSplits",
            e));

        s << i.edgeSplits ();
      }

      // sameDomains
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "sameDomains",
            e));

        s << i.sameDomains ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ColorValue& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ColorValue& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const ColorValue& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const Color& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // r
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "r",
            e));

        s << i.r ();
      }

      // g
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "g",
            e));

        s << i.g ();
      }

      // b
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "b",
            e));

        s << i.b ();
      }

      // a
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "a",
            e));

        s << i.a ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureBase& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // name
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "name",
            e));

        s << i.name ();
      }

      // id
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << i.id ();
      }

      // seerShape
      //
      if (i.seerShape ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "seerShape",
            e));

        s << *i.seerShape ();
      }

      // intersectionMapper
      //
      if (i.intersectionMapper ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "intersectionMapper",
            e));

        s << *i.intersectionMapper ();
      }

      // color
      //
      if (i.color ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "color",
            e));

        s << *i.color ();
      }

      // state
      //
      if (i.state ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "state",
            e));

        s << *i.state ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Pick& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // id
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << i.id ();
      }

      // u
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "u",
            e));

        s << ::xml_schema::AsDouble(i.u ());
      }

      // v
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "v",
            e));

        s << ::xml_schema::AsDouble(i.v ());
      }

      // history
      //
      if (i.history ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "history",
            e));

        s << *i.history ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Picks& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // array
      //
      for (Picks::ArrayConstIterator
           b (i.array ().begin ()), n (i.array ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "array",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PLabel& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // matrix
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "matrix",
            e));

        s << i.matrix ();
      }

      // color
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "color",
            e));

        s << i.color ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CSysDragger& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // matrix
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "matrix",
            e));

        s << i.matrix ();
      }

      // linked
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "linked",
            e));

        s << i.linked ();
      }

      // featureId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "featureId",
            e));

        s << i.featureId ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


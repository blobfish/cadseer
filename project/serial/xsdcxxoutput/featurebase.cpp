// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "featurebase.h"

namespace prj
{
  namespace srl
  {
    // Parameter
    // 

    const Parameter::NameType& Parameter::
    name () const
    {
      return this->name_.get ();
    }

    Parameter::NameType& Parameter::
    name ()
    {
      return this->name_.get ();
    }

    void Parameter::
    name (const NameType& x)
    {
      this->name_.set (x);
    }

    void Parameter::
    name (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const Parameter::NameType& Parameter::
    name_default_value ()
    {
      return name_default_value_;
    }

    const Parameter::ConstantType& Parameter::
    constant () const
    {
      return this->constant_.get ();
    }

    Parameter::ConstantType& Parameter::
    constant ()
    {
      return this->constant_.get ();
    }

    void Parameter::
    constant (const ConstantType& x)
    {
      this->constant_.set (x);
    }

    Parameter::ConstantType Parameter::
    constant_default_value ()
    {
      return ConstantType (true);
    }

    const Parameter::ValueType& Parameter::
    value () const
    {
      return this->value_.get ();
    }

    Parameter::ValueType& Parameter::
    value ()
    {
      return this->value_.get ();
    }

    void Parameter::
    value (const ValueType& x)
    {
      this->value_.set (x);
    }

    Parameter::ValueType Parameter::
    value_default_value ()
    {
      return ValueType (::std::numeric_limits< ::xml_schema::Double >::quiet_NaN ());
    }


    // EvolutionRecord
    // 

    const EvolutionRecord::IdInType& EvolutionRecord::
    idIn () const
    {
      return this->idIn_.get ();
    }

    EvolutionRecord::IdInType& EvolutionRecord::
    idIn ()
    {
      return this->idIn_.get ();
    }

    void EvolutionRecord::
    idIn (const IdInType& x)
    {
      this->idIn_.set (x);
    }

    void EvolutionRecord::
    idIn (::std::unique_ptr< IdInType > x)
    {
      this->idIn_.set (std::move (x));
    }

    const EvolutionRecord::IdInType& EvolutionRecord::
    idIn_default_value ()
    {
      return idIn_default_value_;
    }

    const EvolutionRecord::IdOutType& EvolutionRecord::
    idOut () const
    {
      return this->idOut_.get ();
    }

    EvolutionRecord::IdOutType& EvolutionRecord::
    idOut ()
    {
      return this->idOut_.get ();
    }

    void EvolutionRecord::
    idOut (const IdOutType& x)
    {
      this->idOut_.set (x);
    }

    void EvolutionRecord::
    idOut (::std::unique_ptr< IdOutType > x)
    {
      this->idOut_.set (std::move (x));
    }

    const EvolutionRecord::IdOutType& EvolutionRecord::
    idOut_default_value ()
    {
      return idOut_default_value_;
    }


    // EvolutionContainer
    // 

    const EvolutionContainer::EvolutionRecordSequence& EvolutionContainer::
    evolutionRecord () const
    {
      return this->evolutionRecord_;
    }

    EvolutionContainer::EvolutionRecordSequence& EvolutionContainer::
    evolutionRecord ()
    {
      return this->evolutionRecord_;
    }

    void EvolutionContainer::
    evolutionRecord (const EvolutionRecordSequence& s)
    {
      this->evolutionRecord_ = s;
    }


    // ResultRecord
    // 

    const ResultRecord::IdType& ResultRecord::
    id () const
    {
      return this->id_.get ();
    }

    ResultRecord::IdType& ResultRecord::
    id ()
    {
      return this->id_.get ();
    }

    void ResultRecord::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void ResultRecord::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const ResultRecord::IdType& ResultRecord::
    id_default_value ()
    {
      return id_default_value_;
    }

    const ResultRecord::ShapeOffsetType& ResultRecord::
    shapeOffset () const
    {
      return this->shapeOffset_.get ();
    }

    ResultRecord::ShapeOffsetType& ResultRecord::
    shapeOffset ()
    {
      return this->shapeOffset_.get ();
    }

    void ResultRecord::
    shapeOffset (const ShapeOffsetType& x)
    {
      this->shapeOffset_.set (x);
    }

    ResultRecord::ShapeOffsetType ResultRecord::
    shapeOffset_default_value ()
    {
      return ShapeOffsetType (18446744073709551615ULL);
    }


    // ResultContainer
    // 

    const ResultContainer::ResultRecordSequence& ResultContainer::
    resultRecord () const
    {
      return this->resultRecord_;
    }

    ResultContainer::ResultRecordSequence& ResultContainer::
    resultRecord ()
    {
      return this->resultRecord_;
    }

    void ResultContainer::
    resultRecord (const ResultRecordSequence& s)
    {
      this->resultRecord_ = s;
    }


    // FeatureRecord
    // 

    const FeatureRecord::IdType& FeatureRecord::
    id () const
    {
      return this->id_.get ();
    }

    FeatureRecord::IdType& FeatureRecord::
    id ()
    {
      return this->id_.get ();
    }

    void FeatureRecord::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void FeatureRecord::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const FeatureRecord::IdType& FeatureRecord::
    id_default_value ()
    {
      return id_default_value_;
    }

    const FeatureRecord::TagType& FeatureRecord::
    tag () const
    {
      return this->tag_.get ();
    }

    FeatureRecord::TagType& FeatureRecord::
    tag ()
    {
      return this->tag_.get ();
    }

    void FeatureRecord::
    tag (const TagType& x)
    {
      this->tag_.set (x);
    }

    void FeatureRecord::
    tag (::std::unique_ptr< TagType > x)
    {
      this->tag_.set (std::move (x));
    }

    const FeatureRecord::TagType& FeatureRecord::
    tag_default_value ()
    {
      return tag_default_value_;
    }


    // FeatureContainer
    // 

    const FeatureContainer::FeatureRecordSequence& FeatureContainer::
    featureRecord () const
    {
      return this->featureRecord_;
    }

    FeatureContainer::FeatureRecordSequence& FeatureContainer::
    featureRecord ()
    {
      return this->featureRecord_;
    }

    void FeatureContainer::
    featureRecord (const FeatureRecordSequence& s)
    {
      this->featureRecord_ = s;
    }


    // IdSet
    // 

    const IdSet::IdSequence& IdSet::
    id () const
    {
      return this->id_;
    }

    IdSet::IdSequence& IdSet::
    id ()
    {
      return this->id_;
    }

    void IdSet::
    id (const IdSequence& s)
    {
      this->id_ = s;
    }

    const IdSet::IdType& IdSet::
    id_default_value ()
    {
      return id_default_value_;
    }


    // DerivedRecord
    // 

    const DerivedRecord::IdSetType& DerivedRecord::
    idSet () const
    {
      return this->idSet_.get ();
    }

    DerivedRecord::IdSetType& DerivedRecord::
    idSet ()
    {
      return this->idSet_.get ();
    }

    void DerivedRecord::
    idSet (const IdSetType& x)
    {
      this->idSet_.set (x);
    }

    void DerivedRecord::
    idSet (::std::unique_ptr< IdSetType > x)
    {
      this->idSet_.set (std::move (x));
    }

    const DerivedRecord::IdType& DerivedRecord::
    id () const
    {
      return this->id_.get ();
    }

    DerivedRecord::IdType& DerivedRecord::
    id ()
    {
      return this->id_.get ();
    }

    void DerivedRecord::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void DerivedRecord::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const DerivedRecord::IdType& DerivedRecord::
    id_default_value ()
    {
      return id_default_value_;
    }


    // DerivedContainer
    // 

    const DerivedContainer::DerivedRecordSequence& DerivedContainer::
    derivedRecord () const
    {
      return this->derivedRecord_;
    }

    DerivedContainer::DerivedRecordSequence& DerivedContainer::
    derivedRecord ()
    {
      return this->derivedRecord_;
    }

    void DerivedContainer::
    derivedRecord (const DerivedRecordSequence& s)
    {
      this->derivedRecord_ = s;
    }


    // FeatureBase
    // 

    const FeatureBase::NameType& FeatureBase::
    name () const
    {
      return this->name_.get ();
    }

    FeatureBase::NameType& FeatureBase::
    name ()
    {
      return this->name_.get ();
    }

    void FeatureBase::
    name (const NameType& x)
    {
      this->name_.set (x);
    }

    void FeatureBase::
    name (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const FeatureBase::NameType& FeatureBase::
    name_default_value ()
    {
      return name_default_value_;
    }

    const FeatureBase::IdType& FeatureBase::
    id () const
    {
      return this->id_.get ();
    }

    FeatureBase::IdType& FeatureBase::
    id ()
    {
      return this->id_.get ();
    }

    void FeatureBase::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void FeatureBase::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const FeatureBase::IdType& FeatureBase::
    id_default_value ()
    {
      return id_default_value_;
    }

    const FeatureBase::EvolutionContainerType& FeatureBase::
    evolutionContainer () const
    {
      return this->evolutionContainer_.get ();
    }

    FeatureBase::EvolutionContainerType& FeatureBase::
    evolutionContainer ()
    {
      return this->evolutionContainer_.get ();
    }

    void FeatureBase::
    evolutionContainer (const EvolutionContainerType& x)
    {
      this->evolutionContainer_.set (x);
    }

    void FeatureBase::
    evolutionContainer (::std::unique_ptr< EvolutionContainerType > x)
    {
      this->evolutionContainer_.set (std::move (x));
    }

    const FeatureBase::ResultContainerType& FeatureBase::
    resultContainer () const
    {
      return this->resultContainer_.get ();
    }

    FeatureBase::ResultContainerType& FeatureBase::
    resultContainer ()
    {
      return this->resultContainer_.get ();
    }

    void FeatureBase::
    resultContainer (const ResultContainerType& x)
    {
      this->resultContainer_.set (x);
    }

    void FeatureBase::
    resultContainer (::std::unique_ptr< ResultContainerType > x)
    {
      this->resultContainer_.set (std::move (x));
    }

    const FeatureBase::FeatureContainerType& FeatureBase::
    featureContainer () const
    {
      return this->featureContainer_.get ();
    }

    FeatureBase::FeatureContainerType& FeatureBase::
    featureContainer ()
    {
      return this->featureContainer_.get ();
    }

    void FeatureBase::
    featureContainer (const FeatureContainerType& x)
    {
      this->featureContainer_.set (x);
    }

    void FeatureBase::
    featureContainer (::std::unique_ptr< FeatureContainerType > x)
    {
      this->featureContainer_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace prj
{
  namespace srl
  {
    // Parameter
    //

    const Parameter::NameType Parameter::name_default_value_ (
      "Name");

    Parameter::
    Parameter (const NameType& name,
               const ConstantType& constant,
               const ValueType& value)
    : ::xml_schema::Type (),
      name_ (name, this),
      constant_ (constant, this),
      value_ (value, this)
    {
    }

    Parameter::
    Parameter (const Parameter& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      name_ (x.name_, f, this),
      constant_ (x.constant_, f, this),
      value_ (x.value_, f, this)
    {
    }

    Parameter::
    Parameter (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      name_ (this),
      constant_ (this),
      value_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Parameter::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // name
        //
        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< NameType > r (
            NameTraits::create (i, f, this));

          if (!name_.present ())
          {
            this->name_.set (::std::move (r));
            continue;
          }
        }

        // constant
        //
        if (n.name () == "constant" && n.namespace_ ().empty ())
        {
          if (!constant_.present ())
          {
            this->constant_.set (ConstantTraits::create (i, f, this));
            continue;
          }
        }

        // value
        //
        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          if (!value_.present ())
          {
            this->value_.set (ValueTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!constant_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "constant",
          "");
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "value",
          "");
      }
    }

    Parameter* Parameter::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Parameter (*this, f, c);
    }

    Parameter& Parameter::
    operator= (const Parameter& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->name_ = x.name_;
        this->constant_ = x.constant_;
        this->value_ = x.value_;
      }

      return *this;
    }

    Parameter::
    ~Parameter ()
    {
    }

    // EvolutionRecord
    //

    const EvolutionRecord::IdInType EvolutionRecord::idIn_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    const EvolutionRecord::IdOutType EvolutionRecord::idOut_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    EvolutionRecord::
    EvolutionRecord (const IdInType& idIn,
                     const IdOutType& idOut)
    : ::xml_schema::Type (),
      idIn_ (idIn, this),
      idOut_ (idOut, this)
    {
    }

    EvolutionRecord::
    EvolutionRecord (const EvolutionRecord& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      idIn_ (x.idIn_, f, this),
      idOut_ (x.idOut_, f, this)
    {
    }

    EvolutionRecord::
    EvolutionRecord (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      idIn_ (this),
      idOut_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EvolutionRecord::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // idIn
        //
        if (n.name () == "idIn" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdInType > r (
            IdInTraits::create (i, f, this));

          if (!idIn_.present ())
          {
            this->idIn_.set (::std::move (r));
            continue;
          }
        }

        // idOut
        //
        if (n.name () == "idOut" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdOutType > r (
            IdOutTraits::create (i, f, this));

          if (!idOut_.present ())
          {
            this->idOut_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!idIn_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "idIn",
          "");
      }

      if (!idOut_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "idOut",
          "");
      }
    }

    EvolutionRecord* EvolutionRecord::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EvolutionRecord (*this, f, c);
    }

    EvolutionRecord& EvolutionRecord::
    operator= (const EvolutionRecord& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->idIn_ = x.idIn_;
        this->idOut_ = x.idOut_;
      }

      return *this;
    }

    EvolutionRecord::
    ~EvolutionRecord ()
    {
    }

    // EvolutionContainer
    //

    EvolutionContainer::
    EvolutionContainer ()
    : ::xml_schema::Type (),
      evolutionRecord_ (this)
    {
    }

    EvolutionContainer::
    EvolutionContainer (const EvolutionContainer& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      evolutionRecord_ (x.evolutionRecord_, f, this)
    {
    }

    EvolutionContainer::
    EvolutionContainer (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      evolutionRecord_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EvolutionContainer::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // evolutionRecord
        //
        if (n.name () == "evolutionRecord" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< EvolutionRecordType > r (
            EvolutionRecordTraits::create (i, f, this));

          this->evolutionRecord_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    EvolutionContainer* EvolutionContainer::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EvolutionContainer (*this, f, c);
    }

    EvolutionContainer& EvolutionContainer::
    operator= (const EvolutionContainer& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->evolutionRecord_ = x.evolutionRecord_;
      }

      return *this;
    }

    EvolutionContainer::
    ~EvolutionContainer ()
    {
    }

    // ResultRecord
    //

    const ResultRecord::IdType ResultRecord::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    ResultRecord::
    ResultRecord (const IdType& id,
                  const ShapeOffsetType& shapeOffset)
    : ::xml_schema::Type (),
      id_ (id, this),
      shapeOffset_ (shapeOffset, this)
    {
    }

    ResultRecord::
    ResultRecord (const ResultRecord& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this),
      shapeOffset_ (x.shapeOffset_, f, this)
    {
    }

    ResultRecord::
    ResultRecord (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this),
      shapeOffset_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ResultRecord::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          if (!id_.present ())
          {
            this->id_.set (::std::move (r));
            continue;
          }
        }

        // shapeOffset
        //
        if (n.name () == "shapeOffset" && n.namespace_ ().empty ())
        {
          if (!shapeOffset_.present ())
          {
            this->shapeOffset_.set (ShapeOffsetTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!shapeOffset_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "shapeOffset",
          "");
      }
    }

    ResultRecord* ResultRecord::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ResultRecord (*this, f, c);
    }

    ResultRecord& ResultRecord::
    operator= (const ResultRecord& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
        this->shapeOffset_ = x.shapeOffset_;
      }

      return *this;
    }

    ResultRecord::
    ~ResultRecord ()
    {
    }

    // ResultContainer
    //

    ResultContainer::
    ResultContainer ()
    : ::xml_schema::Type (),
      resultRecord_ (this)
    {
    }

    ResultContainer::
    ResultContainer (const ResultContainer& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      resultRecord_ (x.resultRecord_, f, this)
    {
    }

    ResultContainer::
    ResultContainer (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      resultRecord_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ResultContainer::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // resultRecord
        //
        if (n.name () == "resultRecord" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ResultRecordType > r (
            ResultRecordTraits::create (i, f, this));

          this->resultRecord_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    ResultContainer* ResultContainer::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ResultContainer (*this, f, c);
    }

    ResultContainer& ResultContainer::
    operator= (const ResultContainer& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->resultRecord_ = x.resultRecord_;
      }

      return *this;
    }

    ResultContainer::
    ~ResultContainer ()
    {
    }

    // FeatureRecord
    //

    const FeatureRecord::IdType FeatureRecord::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    const FeatureRecord::TagType FeatureRecord::tag_default_value_ (
      "");

    FeatureRecord::
    FeatureRecord (const IdType& id,
                   const TagType& tag)
    : ::xml_schema::Type (),
      id_ (id, this),
      tag_ (tag, this)
    {
    }

    FeatureRecord::
    FeatureRecord (const FeatureRecord& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this),
      tag_ (x.tag_, f, this)
    {
    }

    FeatureRecord::
    FeatureRecord (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this),
      tag_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureRecord::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          if (!id_.present ())
          {
            this->id_.set (::std::move (r));
            continue;
          }
        }

        // tag
        //
        if (n.name () == "tag" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< TagType > r (
            TagTraits::create (i, f, this));

          if (!tag_.present ())
          {
            this->tag_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!tag_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "tag",
          "");
      }
    }

    FeatureRecord* FeatureRecord::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FeatureRecord (*this, f, c);
    }

    FeatureRecord& FeatureRecord::
    operator= (const FeatureRecord& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
        this->tag_ = x.tag_;
      }

      return *this;
    }

    FeatureRecord::
    ~FeatureRecord ()
    {
    }

    // FeatureContainer
    //

    FeatureContainer::
    FeatureContainer ()
    : ::xml_schema::Type (),
      featureRecord_ (this)
    {
    }

    FeatureContainer::
    FeatureContainer (const FeatureContainer& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      featureRecord_ (x.featureRecord_, f, this)
    {
    }

    FeatureContainer::
    FeatureContainer (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      featureRecord_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureContainer::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // featureRecord
        //
        if (n.name () == "featureRecord" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< FeatureRecordType > r (
            FeatureRecordTraits::create (i, f, this));

          this->featureRecord_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    FeatureContainer* FeatureContainer::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FeatureContainer (*this, f, c);
    }

    FeatureContainer& FeatureContainer::
    operator= (const FeatureContainer& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->featureRecord_ = x.featureRecord_;
      }

      return *this;
    }

    FeatureContainer::
    ~FeatureContainer ()
    {
    }

    // IdSet
    //

    const IdSet::IdType IdSet::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    IdSet::
    IdSet ()
    : ::xml_schema::Type (),
      id_ (this)
    {
    }

    IdSet::
    IdSet (const IdSet& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this)
    {
    }

    IdSet::
    IdSet (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void IdSet::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->id_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    IdSet* IdSet::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IdSet (*this, f, c);
    }

    IdSet& IdSet::
    operator= (const IdSet& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
      }

      return *this;
    }

    IdSet::
    ~IdSet ()
    {
    }

    // DerivedRecord
    //

    const DerivedRecord::IdType DerivedRecord::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    DerivedRecord::
    DerivedRecord (const IdSetType& idSet,
                   const IdType& id)
    : ::xml_schema::Type (),
      idSet_ (idSet, this),
      id_ (id, this)
    {
    }

    DerivedRecord::
    DerivedRecord (::std::unique_ptr< IdSetType > idSet,
                   const IdType& id)
    : ::xml_schema::Type (),
      idSet_ (std::move (idSet), this),
      id_ (id, this)
    {
    }

    DerivedRecord::
    DerivedRecord (const DerivedRecord& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      idSet_ (x.idSet_, f, this),
      id_ (x.id_, f, this)
    {
    }

    DerivedRecord::
    DerivedRecord (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      idSet_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DerivedRecord::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // idSet
        //
        if (n.name () == "idSet" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdSetType > r (
            IdSetTraits::create (i, f, this));

          if (!idSet_.present ())
          {
            this->idSet_.set (::std::move (r));
            continue;
          }
        }

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          if (!id_.present ())
          {
            this->id_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!idSet_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "idSet",
          "");
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }
    }

    DerivedRecord* DerivedRecord::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DerivedRecord (*this, f, c);
    }

    DerivedRecord& DerivedRecord::
    operator= (const DerivedRecord& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->idSet_ = x.idSet_;
        this->id_ = x.id_;
      }

      return *this;
    }

    DerivedRecord::
    ~DerivedRecord ()
    {
    }

    // DerivedContainer
    //

    DerivedContainer::
    DerivedContainer ()
    : ::xml_schema::Type (),
      derivedRecord_ (this)
    {
    }

    DerivedContainer::
    DerivedContainer (const DerivedContainer& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      derivedRecord_ (x.derivedRecord_, f, this)
    {
    }

    DerivedContainer::
    DerivedContainer (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      derivedRecord_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DerivedContainer::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // derivedRecord
        //
        if (n.name () == "derivedRecord" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< DerivedRecordType > r (
            DerivedRecordTraits::create (i, f, this));

          this->derivedRecord_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    DerivedContainer* DerivedContainer::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DerivedContainer (*this, f, c);
    }

    DerivedContainer& DerivedContainer::
    operator= (const DerivedContainer& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->derivedRecord_ = x.derivedRecord_;
      }

      return *this;
    }

    DerivedContainer::
    ~DerivedContainer ()
    {
    }

    // FeatureBase
    //

    const FeatureBase::NameType FeatureBase::name_default_value_ (
      "Empty");

    const FeatureBase::IdType FeatureBase::id_default_value_ (
      "00000000-0000-0000-0000-000000000000");

    FeatureBase::
    FeatureBase (const NameType& name,
                 const IdType& id,
                 const EvolutionContainerType& evolutionContainer,
                 const ResultContainerType& resultContainer,
                 const FeatureContainerType& featureContainer)
    : ::xml_schema::Type (),
      name_ (name, this),
      id_ (id, this),
      evolutionContainer_ (evolutionContainer, this),
      resultContainer_ (resultContainer, this),
      featureContainer_ (featureContainer, this)
    {
    }

    FeatureBase::
    FeatureBase (const NameType& name,
                 const IdType& id,
                 ::std::unique_ptr< EvolutionContainerType > evolutionContainer,
                 ::std::unique_ptr< ResultContainerType > resultContainer,
                 ::std::unique_ptr< FeatureContainerType > featureContainer)
    : ::xml_schema::Type (),
      name_ (name, this),
      id_ (id, this),
      evolutionContainer_ (std::move (evolutionContainer), this),
      resultContainer_ (std::move (resultContainer), this),
      featureContainer_ (std::move (featureContainer), this)
    {
    }

    FeatureBase::
    FeatureBase (const FeatureBase& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      name_ (x.name_, f, this),
      id_ (x.id_, f, this),
      evolutionContainer_ (x.evolutionContainer_, f, this),
      resultContainer_ (x.resultContainer_, f, this),
      featureContainer_ (x.featureContainer_, f, this)
    {
    }

    FeatureBase::
    FeatureBase (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      name_ (this),
      id_ (this),
      evolutionContainer_ (this),
      resultContainer_ (this),
      featureContainer_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureBase::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // name
        //
        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< NameType > r (
            NameTraits::create (i, f, this));

          if (!name_.present ())
          {
            this->name_.set (::std::move (r));
            continue;
          }
        }

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IdType > r (
            IdTraits::create (i, f, this));

          if (!id_.present ())
          {
            this->id_.set (::std::move (r));
            continue;
          }
        }

        // evolutionContainer
        //
        if (n.name () == "evolutionContainer" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< EvolutionContainerType > r (
            EvolutionContainerTraits::create (i, f, this));

          if (!evolutionContainer_.present ())
          {
            this->evolutionContainer_.set (::std::move (r));
            continue;
          }
        }

        // resultContainer
        //
        if (n.name () == "resultContainer" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ResultContainerType > r (
            ResultContainerTraits::create (i, f, this));

          if (!resultContainer_.present ())
          {
            this->resultContainer_.set (::std::move (r));
            continue;
          }
        }

        // featureContainer
        //
        if (n.name () == "featureContainer" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< FeatureContainerType > r (
            FeatureContainerTraits::create (i, f, this));

          if (!featureContainer_.present ())
          {
            this->featureContainer_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!evolutionContainer_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "evolutionContainer",
          "");
      }

      if (!resultContainer_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "resultContainer",
          "");
      }

      if (!featureContainer_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "featureContainer",
          "");
      }
    }

    FeatureBase* FeatureBase::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FeatureBase (*this, f, c);
    }

    FeatureBase& FeatureBase::
    operator= (const FeatureBase& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->name_ = x.name_;
        this->id_ = x.id_;
        this->evolutionContainer_ = x.evolutionContainer_;
        this->resultContainer_ = x.resultContainer_;
        this->featureContainer_ = x.featureContainer_;
      }

      return *this;
    }

    FeatureBase::
    ~FeatureBase ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace prj
{
  namespace srl
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace prj
{
  namespace srl
  {
    void
    operator<< (::xercesc::DOMElement& e, const Parameter& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // name
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "name",
            e));

        s << i.name ();
      }

      // constant
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "constant",
            e));

        s << i.constant ();
      }

      // value
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "value",
            e));

        s << ::xml_schema::AsDouble(i.value ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EvolutionRecord& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // idIn
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "idIn",
            e));

        s << i.idIn ();
      }

      // idOut
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "idOut",
            e));

        s << i.idOut ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EvolutionContainer& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // evolutionRecord
      //
      for (EvolutionContainer::EvolutionRecordConstIterator
           b (i.evolutionRecord ().begin ()), n (i.evolutionRecord ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "evolutionRecord",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ResultRecord& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // id
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << i.id ();
      }

      // shapeOffset
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "shapeOffset",
            e));

        s << i.shapeOffset ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ResultContainer& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // resultRecord
      //
      for (ResultContainer::ResultRecordConstIterator
           b (i.resultRecord ().begin ()), n (i.resultRecord ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "resultRecord",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureRecord& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // id
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << i.id ();
      }

      // tag
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "tag",
            e));

        s << i.tag ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureContainer& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // featureRecord
      //
      for (FeatureContainer::FeatureRecordConstIterator
           b (i.featureRecord ().begin ()), n (i.featureRecord ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "featureRecord",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IdSet& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // id
      //
      for (IdSet::IdConstIterator
           b (i.id ().begin ()), n (i.id ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DerivedRecord& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // idSet
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "idSet",
            e));

        s << i.idSet ();
      }

      // id
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DerivedContainer& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // derivedRecord
      //
      for (DerivedContainer::DerivedRecordConstIterator
           b (i.derivedRecord ().begin ()), n (i.derivedRecord ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "derivedRecord",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureBase& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // name
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "name",
            e));

        s << i.name ();
      }

      // id
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << i.id ();
      }

      // evolutionContainer
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "evolutionContainer",
            e));

        s << i.evolutionContainer ();
      }

      // resultContainer
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "resultContainer",
            e));

        s << i.resultContainer ();
      }

      // featureContainer
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "featureContainer",
            e));

        s << i.featureContainer ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


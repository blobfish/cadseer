// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "featurequote.h"

namespace prj
{
  namespace srl
  {
    // FeatureQuote
    // 

    const FeatureQuote::FeatureBaseType& FeatureQuote::
    featureBase () const
    {
      return this->featureBase_.get ();
    }

    FeatureQuote::FeatureBaseType& FeatureQuote::
    featureBase ()
    {
      return this->featureBase_.get ();
    }

    void FeatureQuote::
    featureBase (const FeatureBaseType& x)
    {
      this->featureBase_.set (x);
    }

    void FeatureQuote::
    featureBase (::std::unique_ptr< FeatureBaseType > x)
    {
      this->featureBase_.set (std::move (x));
    }

    const FeatureQuote::TemplateFileType& FeatureQuote::
    templateFile () const
    {
      return this->templateFile_.get ();
    }

    FeatureQuote::TemplateFileType& FeatureQuote::
    templateFile ()
    {
      return this->templateFile_.get ();
    }

    void FeatureQuote::
    templateFile (const TemplateFileType& x)
    {
      this->templateFile_.set (x);
    }

    void FeatureQuote::
    templateFile (::std::unique_ptr< TemplateFileType > x)
    {
      this->templateFile_.set (std::move (x));
    }

    const FeatureQuote::OutFileType& FeatureQuote::
    outFile () const
    {
      return this->outFile_.get ();
    }

    FeatureQuote::OutFileType& FeatureQuote::
    outFile ()
    {
      return this->outFile_.get ();
    }

    void FeatureQuote::
    outFile (const OutFileType& x)
    {
      this->outFile_.set (x);
    }

    void FeatureQuote::
    outFile (::std::unique_ptr< OutFileType > x)
    {
      this->outFile_.set (std::move (x));
    }

    const FeatureQuote::PictureFileType& FeatureQuote::
    pictureFile () const
    {
      return this->pictureFile_.get ();
    }

    FeatureQuote::PictureFileType& FeatureQuote::
    pictureFile ()
    {
      return this->pictureFile_.get ();
    }

    void FeatureQuote::
    pictureFile (const PictureFileType& x)
    {
      this->pictureFile_.set (x);
    }

    void FeatureQuote::
    pictureFile (::std::unique_ptr< PictureFileType > x)
    {
      this->pictureFile_.set (std::move (x));
    }

    const FeatureQuote::QuoteNumberType& FeatureQuote::
    quoteNumber () const
    {
      return this->quoteNumber_.get ();
    }

    FeatureQuote::QuoteNumberType& FeatureQuote::
    quoteNumber ()
    {
      return this->quoteNumber_.get ();
    }

    void FeatureQuote::
    quoteNumber (const QuoteNumberType& x)
    {
      this->quoteNumber_.set (x);
    }

    const FeatureQuote::CustomerNameType& FeatureQuote::
    customerName () const
    {
      return this->customerName_.get ();
    }

    FeatureQuote::CustomerNameType& FeatureQuote::
    customerName ()
    {
      return this->customerName_.get ();
    }

    void FeatureQuote::
    customerName (const CustomerNameType& x)
    {
      this->customerName_.set (x);
    }

    void FeatureQuote::
    customerName (::std::unique_ptr< CustomerNameType > x)
    {
      this->customerName_.set (std::move (x));
    }

    const FeatureQuote::CustomerIdType& FeatureQuote::
    customerId () const
    {
      return this->customerId_.get ();
    }

    FeatureQuote::CustomerIdType& FeatureQuote::
    customerId ()
    {
      return this->customerId_.get ();
    }

    void FeatureQuote::
    customerId (const CustomerIdType& x)
    {
      this->customerId_.set (x);
    }

    void FeatureQuote::
    customerId (::std::unique_ptr< CustomerIdType > x)
    {
      this->customerId_.set (std::move (x));
    }

    const FeatureQuote::PartNameType& FeatureQuote::
    partName () const
    {
      return this->partName_.get ();
    }

    FeatureQuote::PartNameType& FeatureQuote::
    partName ()
    {
      return this->partName_.get ();
    }

    void FeatureQuote::
    partName (const PartNameType& x)
    {
      this->partName_.set (x);
    }

    void FeatureQuote::
    partName (::std::unique_ptr< PartNameType > x)
    {
      this->partName_.set (std::move (x));
    }

    const FeatureQuote::PartNumberType& FeatureQuote::
    partNumber () const
    {
      return this->partNumber_.get ();
    }

    FeatureQuote::PartNumberType& FeatureQuote::
    partNumber ()
    {
      return this->partNumber_.get ();
    }

    void FeatureQuote::
    partNumber (const PartNumberType& x)
    {
      this->partNumber_.set (x);
    }

    void FeatureQuote::
    partNumber (::std::unique_ptr< PartNumberType > x)
    {
      this->partNumber_.set (std::move (x));
    }

    const FeatureQuote::PartSetupType& FeatureQuote::
    partSetup () const
    {
      return this->partSetup_.get ();
    }

    FeatureQuote::PartSetupType& FeatureQuote::
    partSetup ()
    {
      return this->partSetup_.get ();
    }

    void FeatureQuote::
    partSetup (const PartSetupType& x)
    {
      this->partSetup_.set (x);
    }

    void FeatureQuote::
    partSetup (::std::unique_ptr< PartSetupType > x)
    {
      this->partSetup_.set (std::move (x));
    }

    const FeatureQuote::PartRevisionType& FeatureQuote::
    partRevision () const
    {
      return this->partRevision_.get ();
    }

    FeatureQuote::PartRevisionType& FeatureQuote::
    partRevision ()
    {
      return this->partRevision_.get ();
    }

    void FeatureQuote::
    partRevision (const PartRevisionType& x)
    {
      this->partRevision_.set (x);
    }

    void FeatureQuote::
    partRevision (::std::unique_ptr< PartRevisionType > x)
    {
      this->partRevision_.set (std::move (x));
    }

    const FeatureQuote::MaterialTypeType& FeatureQuote::
    materialType () const
    {
      return this->materialType_.get ();
    }

    FeatureQuote::MaterialTypeType& FeatureQuote::
    materialType ()
    {
      return this->materialType_.get ();
    }

    void FeatureQuote::
    materialType (const MaterialTypeType& x)
    {
      this->materialType_.set (x);
    }

    void FeatureQuote::
    materialType (::std::unique_ptr< MaterialTypeType > x)
    {
      this->materialType_.set (std::move (x));
    }

    const FeatureQuote::MaterialThicknessType& FeatureQuote::
    materialThickness () const
    {
      return this->materialThickness_.get ();
    }

    FeatureQuote::MaterialThicknessType& FeatureQuote::
    materialThickness ()
    {
      return this->materialThickness_.get ();
    }

    void FeatureQuote::
    materialThickness (const MaterialThicknessType& x)
    {
      this->materialThickness_.set (x);
    }

    const FeatureQuote::ProcessTypeType& FeatureQuote::
    processType () const
    {
      return this->processType_.get ();
    }

    FeatureQuote::ProcessTypeType& FeatureQuote::
    processType ()
    {
      return this->processType_.get ();
    }

    void FeatureQuote::
    processType (const ProcessTypeType& x)
    {
      this->processType_.set (x);
    }

    void FeatureQuote::
    processType (::std::unique_ptr< ProcessTypeType > x)
    {
      this->processType_.set (std::move (x));
    }

    const FeatureQuote::AnnualVolumeType& FeatureQuote::
    annualVolume () const
    {
      return this->annualVolume_.get ();
    }

    FeatureQuote::AnnualVolumeType& FeatureQuote::
    annualVolume ()
    {
      return this->annualVolume_.get ();
    }

    void FeatureQuote::
    annualVolume (const AnnualVolumeType& x)
    {
      this->annualVolume_.set (x);
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace prj
{
  namespace srl
  {
    // FeatureQuote
    //

    FeatureQuote::
    FeatureQuote (const FeatureBaseType& featureBase,
                  const TemplateFileType& templateFile,
                  const OutFileType& outFile,
                  const PictureFileType& pictureFile,
                  const QuoteNumberType& quoteNumber,
                  const CustomerNameType& customerName,
                  const CustomerIdType& customerId,
                  const PartNameType& partName,
                  const PartNumberType& partNumber,
                  const PartSetupType& partSetup,
                  const PartRevisionType& partRevision,
                  const MaterialTypeType& materialType,
                  const MaterialThicknessType& materialThickness,
                  const ProcessTypeType& processType,
                  const AnnualVolumeType& annualVolume)
    : ::xml_schema::Type (),
      featureBase_ (featureBase, this),
      templateFile_ (templateFile, this),
      outFile_ (outFile, this),
      pictureFile_ (pictureFile, this),
      quoteNumber_ (quoteNumber, this),
      customerName_ (customerName, this),
      customerId_ (customerId, this),
      partName_ (partName, this),
      partNumber_ (partNumber, this),
      partSetup_ (partSetup, this),
      partRevision_ (partRevision, this),
      materialType_ (materialType, this),
      materialThickness_ (materialThickness, this),
      processType_ (processType, this),
      annualVolume_ (annualVolume, this)
    {
    }

    FeatureQuote::
    FeatureQuote (::std::unique_ptr< FeatureBaseType > featureBase,
                  const TemplateFileType& templateFile,
                  const OutFileType& outFile,
                  const PictureFileType& pictureFile,
                  const QuoteNumberType& quoteNumber,
                  const CustomerNameType& customerName,
                  const CustomerIdType& customerId,
                  const PartNameType& partName,
                  const PartNumberType& partNumber,
                  const PartSetupType& partSetup,
                  const PartRevisionType& partRevision,
                  const MaterialTypeType& materialType,
                  const MaterialThicknessType& materialThickness,
                  const ProcessTypeType& processType,
                  const AnnualVolumeType& annualVolume)
    : ::xml_schema::Type (),
      featureBase_ (std::move (featureBase), this),
      templateFile_ (templateFile, this),
      outFile_ (outFile, this),
      pictureFile_ (pictureFile, this),
      quoteNumber_ (quoteNumber, this),
      customerName_ (customerName, this),
      customerId_ (customerId, this),
      partName_ (partName, this),
      partNumber_ (partNumber, this),
      partSetup_ (partSetup, this),
      partRevision_ (partRevision, this),
      materialType_ (materialType, this),
      materialThickness_ (materialThickness, this),
      processType_ (processType, this),
      annualVolume_ (annualVolume, this)
    {
    }

    FeatureQuote::
    FeatureQuote (const FeatureQuote& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      featureBase_ (x.featureBase_, f, this),
      templateFile_ (x.templateFile_, f, this),
      outFile_ (x.outFile_, f, this),
      pictureFile_ (x.pictureFile_, f, this),
      quoteNumber_ (x.quoteNumber_, f, this),
      customerName_ (x.customerName_, f, this),
      customerId_ (x.customerId_, f, this),
      partName_ (x.partName_, f, this),
      partNumber_ (x.partNumber_, f, this),
      partSetup_ (x.partSetup_, f, this),
      partRevision_ (x.partRevision_, f, this),
      materialType_ (x.materialType_, f, this),
      materialThickness_ (x.materialThickness_, f, this),
      processType_ (x.processType_, f, this),
      annualVolume_ (x.annualVolume_, f, this)
    {
    }

    FeatureQuote::
    FeatureQuote (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      featureBase_ (this),
      templateFile_ (this),
      outFile_ (this),
      pictureFile_ (this),
      quoteNumber_ (this),
      customerName_ (this),
      customerId_ (this),
      partName_ (this),
      partNumber_ (this),
      partSetup_ (this),
      partRevision_ (this),
      materialType_ (this),
      materialThickness_ (this),
      processType_ (this),
      annualVolume_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureQuote::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // featureBase
        //
        if (n.name () == "featureBase" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< FeatureBaseType > r (
            FeatureBaseTraits::create (i, f, this));

          if (!featureBase_.present ())
          {
            this->featureBase_.set (::std::move (r));
            continue;
          }
        }

        // templateFile
        //
        if (n.name () == "templateFile" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< TemplateFileType > r (
            TemplateFileTraits::create (i, f, this));

          if (!templateFile_.present ())
          {
            this->templateFile_.set (::std::move (r));
            continue;
          }
        }

        // outFile
        //
        if (n.name () == "outFile" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< OutFileType > r (
            OutFileTraits::create (i, f, this));

          if (!outFile_.present ())
          {
            this->outFile_.set (::std::move (r));
            continue;
          }
        }

        // pictureFile
        //
        if (n.name () == "pictureFile" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< PictureFileType > r (
            PictureFileTraits::create (i, f, this));

          if (!pictureFile_.present ())
          {
            this->pictureFile_.set (::std::move (r));
            continue;
          }
        }

        // quoteNumber
        //
        if (n.name () == "quoteNumber" && n.namespace_ ().empty ())
        {
          if (!quoteNumber_.present ())
          {
            this->quoteNumber_.set (QuoteNumberTraits::create (i, f, this));
            continue;
          }
        }

        // customerName
        //
        if (n.name () == "customerName" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< CustomerNameType > r (
            CustomerNameTraits::create (i, f, this));

          if (!customerName_.present ())
          {
            this->customerName_.set (::std::move (r));
            continue;
          }
        }

        // customerId
        //
        if (n.name () == "customerId" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< CustomerIdType > r (
            CustomerIdTraits::create (i, f, this));

          if (!customerId_.present ())
          {
            this->customerId_.set (::std::move (r));
            continue;
          }
        }

        // partName
        //
        if (n.name () == "partName" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< PartNameType > r (
            PartNameTraits::create (i, f, this));

          if (!partName_.present ())
          {
            this->partName_.set (::std::move (r));
            continue;
          }
        }

        // partNumber
        //
        if (n.name () == "partNumber" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< PartNumberType > r (
            PartNumberTraits::create (i, f, this));

          if (!partNumber_.present ())
          {
            this->partNumber_.set (::std::move (r));
            continue;
          }
        }

        // partSetup
        //
        if (n.name () == "partSetup" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< PartSetupType > r (
            PartSetupTraits::create (i, f, this));

          if (!partSetup_.present ())
          {
            this->partSetup_.set (::std::move (r));
            continue;
          }
        }

        // partRevision
        //
        if (n.name () == "partRevision" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< PartRevisionType > r (
            PartRevisionTraits::create (i, f, this));

          if (!partRevision_.present ())
          {
            this->partRevision_.set (::std::move (r));
            continue;
          }
        }

        // materialType
        //
        if (n.name () == "materialType" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< MaterialTypeType > r (
            MaterialTypeTraits::create (i, f, this));

          if (!materialType_.present ())
          {
            this->materialType_.set (::std::move (r));
            continue;
          }
        }

        // materialThickness
        //
        if (n.name () == "materialThickness" && n.namespace_ ().empty ())
        {
          if (!materialThickness_.present ())
          {
            this->materialThickness_.set (MaterialThicknessTraits::create (i, f, this));
            continue;
          }
        }

        // processType
        //
        if (n.name () == "processType" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ProcessTypeType > r (
            ProcessTypeTraits::create (i, f, this));

          if (!processType_.present ())
          {
            this->processType_.set (::std::move (r));
            continue;
          }
        }

        // annualVolume
        //
        if (n.name () == "annualVolume" && n.namespace_ ().empty ())
        {
          if (!annualVolume_.present ())
          {
            this->annualVolume_.set (AnnualVolumeTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!featureBase_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "featureBase",
          "");
      }

      if (!templateFile_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "templateFile",
          "");
      }

      if (!outFile_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "outFile",
          "");
      }

      if (!pictureFile_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "pictureFile",
          "");
      }

      if (!quoteNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "quoteNumber",
          "");
      }

      if (!customerName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "customerName",
          "");
      }

      if (!customerId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "customerId",
          "");
      }

      if (!partName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "partName",
          "");
      }

      if (!partNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "partNumber",
          "");
      }

      if (!partSetup_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "partSetup",
          "");
      }

      if (!partRevision_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "partRevision",
          "");
      }

      if (!materialType_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "materialType",
          "");
      }

      if (!materialThickness_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "materialThickness",
          "");
      }

      if (!processType_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "processType",
          "");
      }

      if (!annualVolume_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "annualVolume",
          "");
      }
    }

    FeatureQuote* FeatureQuote::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FeatureQuote (*this, f, c);
    }

    FeatureQuote& FeatureQuote::
    operator= (const FeatureQuote& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->featureBase_ = x.featureBase_;
        this->templateFile_ = x.templateFile_;
        this->outFile_ = x.outFile_;
        this->pictureFile_ = x.pictureFile_;
        this->quoteNumber_ = x.quoteNumber_;
        this->customerName_ = x.customerName_;
        this->customerId_ = x.customerId_;
        this->partName_ = x.partName_;
        this->partNumber_ = x.partNumber_;
        this->partSetup_ = x.partSetup_;
        this->partRevision_ = x.partRevision_;
        this->materialType_ = x.materialType_;
        this->materialThickness_ = x.materialThickness_;
        this->processType_ = x.processType_;
        this->annualVolume_ = x.annualVolume_;
      }

      return *this;
    }

    FeatureQuote::
    ~FeatureQuote ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace prj
{
  namespace srl
  {
    ::std::unique_ptr< ::prj::srl::FeatureQuote >
    quote (const ::std::string& u,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::prj::srl::FeatureQuote > (
        ::prj::srl::quote (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::prj::srl::FeatureQuote >
    quote (const ::std::string& u,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::prj::srl::FeatureQuote > (
        ::prj::srl::quote (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::prj::srl::FeatureQuote >
    quote (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::prj::srl::FeatureQuote > (
        ::prj::srl::quote (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::prj::srl::FeatureQuote >
    quote (::std::istream& is,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::prj::srl::quote (isrc, f, p);
    }

    ::std::unique_ptr< ::prj::srl::FeatureQuote >
    quote (::std::istream& is,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::prj::srl::quote (isrc, h, f, p);
    }

    ::std::unique_ptr< ::prj::srl::FeatureQuote >
    quote (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::prj::srl::quote (isrc, h, f, p);
    }

    ::std::unique_ptr< ::prj::srl::FeatureQuote >
    quote (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::prj::srl::quote (isrc, f, p);
    }

    ::std::unique_ptr< ::prj::srl::FeatureQuote >
    quote (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::prj::srl::quote (isrc, h, f, p);
    }

    ::std::unique_ptr< ::prj::srl::FeatureQuote >
    quote (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::prj::srl::quote (isrc, h, f, p);
    }

    ::std::unique_ptr< ::prj::srl::FeatureQuote >
    quote (::xercesc::InputSource& i,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::prj::srl::FeatureQuote > (
        ::prj::srl::quote (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::prj::srl::FeatureQuote >
    quote (::xercesc::InputSource& i,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::prj::srl::FeatureQuote > (
        ::prj::srl::quote (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::prj::srl::FeatureQuote >
    quote (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::prj::srl::FeatureQuote > (
        ::prj::srl::quote (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::prj::srl::FeatureQuote >
    quote (const ::xercesc::DOMDocument& doc,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::prj::srl::FeatureQuote > (
          ::prj::srl::quote (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "quote" &&
          n.namespace_ () == "http://www.cadseer.com/prj/srl")
      {
        ::std::unique_ptr< ::prj::srl::FeatureQuote > r (
          ::xsd::cxx::tree::traits< ::prj::srl::FeatureQuote, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "quote",
        "http://www.cadseer.com/prj/srl");
    }

    ::std::unique_ptr< ::prj::srl::FeatureQuote >
    quote (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "quote" &&
          n.namespace_ () == "http://www.cadseer.com/prj/srl")
      {
        ::std::unique_ptr< ::prj::srl::FeatureQuote > r (
          ::xsd::cxx::tree::traits< ::prj::srl::FeatureQuote, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "quote",
        "http://www.cadseer.com/prj/srl");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace prj
{
  namespace srl
  {
    void
    operator<< (::xercesc::DOMElement& e, const FeatureQuote& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // featureBase
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "featureBase",
            e));

        s << i.featureBase ();
      }

      // templateFile
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "templateFile",
            e));

        s << i.templateFile ();
      }

      // outFile
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "outFile",
            e));

        s << i.outFile ();
      }

      // pictureFile
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "pictureFile",
            e));

        s << i.pictureFile ();
      }

      // quoteNumber
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "quoteNumber",
            e));

        s << i.quoteNumber ();
      }

      // customerName
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "customerName",
            e));

        s << i.customerName ();
      }

      // customerId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "customerId",
            e));

        s << i.customerId ();
      }

      // partName
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "partName",
            e));

        s << i.partName ();
      }

      // partNumber
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "partNumber",
            e));

        s << i.partNumber ();
      }

      // partSetup
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "partSetup",
            e));

        s << i.partSetup ();
      }

      // partRevision
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "partRevision",
            e));

        s << i.partRevision ();
      }

      // materialType
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "materialType",
            e));

        s << i.materialType ();
      }

      // materialThickness
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "materialThickness",
            e));

        s << ::xml_schema::AsDouble(i.materialThickness ());
      }

      // processType
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "processType",
            e));

        s << i.processType ();
      }

      // annualVolume
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "annualVolume",
            e));

        s << i.annualVolume ();
      }
    }

    void
    quote (::std::ostream& o,
           const ::prj::srl::FeatureQuote& s,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::prj::srl::quote (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    quote (::std::ostream& o,
           const ::prj::srl::FeatureQuote& s,
           ::xml_schema::ErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::prj::srl::quote (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    quote (::std::ostream& o,
           const ::prj::srl::FeatureQuote& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::prj::srl::quote (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    quote (::xercesc::XMLFormatTarget& t,
           const ::prj::srl::FeatureQuote& s,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::prj::srl::quote (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    quote (::xercesc::XMLFormatTarget& t,
           const ::prj::srl::FeatureQuote& s,
           ::xml_schema::ErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::prj::srl::quote (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    quote (::xercesc::XMLFormatTarget& t,
           const ::prj::srl::FeatureQuote& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::prj::srl::quote (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    quote (::xercesc::DOMDocument& d,
           const ::prj::srl::FeatureQuote& s,
           ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "quote" &&
          n.namespace_ () == "http://www.cadseer.com/prj/srl")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "quote",
          "http://www.cadseer.com/prj/srl");
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    quote (const ::prj::srl::FeatureQuote& s,
           const ::xml_schema::NamespaceInfomap& m,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "quote",
          "http://www.cadseer.com/prj/srl",
          m, f));

      ::prj::srl::quote (*d, s, f);
      return d;
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

